<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>David's World</title>
        <description>David's World - David</description>
        <link>http://spetacular.github.io</link>
        <atom:link href="http://spetacular.github.io/rss.xml" rel="self" type="application/rss+xml" />
        <lastBuildDate>Fri, 14 Apr 2017 18:53:09 +0800</lastBuildDate>
        <pubDate>Fri, 14 Apr 2017 18:53:09 +0800</pubDate>
        <ttl>60</ttl>


        <item>
                <title>Nginx缓存最佳实践</title>
                <description>&lt;p&gt;与&lt;a href=&quot;https://varnish-cache.org/&quot;&gt;Varnish&lt;/a&gt;类似，&lt;a href=&quot;https://nginx.org/&quot;&gt;Nginx&lt;/a&gt;非常适合做网页缓存。许多管理员转向Varnish，因为Varnish确实有用。但是，Nginx也有如下优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nginx能非常有效地直接处理静态内容。在静态文件和Nginx在同一主机的情况下，这种特性尤为有用。&lt;/li&gt;
  &lt;li&gt;当放置在应用服务器前端时，Nginx确实能够担当缓存服务器的角色。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然Varnish作为网页缓存服务器拥有比Nginx更丰富的缓存相关的特性，但是Nginx仍然是一个不错的选择。&lt;/p&gt;

&lt;p&gt;如果您的流量需要为缓存添加一层基础设施，但不需要引入学习和维护的新技术的开销，Nginx可能更适合。&lt;/p&gt;

&lt;p&gt;如果您碰巧使用Nginx Plus，它具有支持和额外的功能，这一点尤其如此。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;用例&lt;/h1&gt;

&lt;p&gt;Nginx自己处理静态内容。这是Web服务器的典型用例，而不是缓存服务器。然而，由于Nginx可以向其他Web服务器或应用程序（通过HTTP，FastCGI和uWSGI）代理请求，因此通常用于在向其他进程代理应用程序请求时提高服务静态文件的性能。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是一个常见的架构，但是PHP的用户可能会使用Apache + Apache的&lt;code class=&quot;highlighter-rouge&quot;&gt;mod_php&lt;/code&gt;，它将PHP“内置”到Apache中，使得它似乎一切都在一个神奇（但效率较低）的地方。
除了直接提供静态文件的能力外，Nginx还可以作为缓存服务器，这意味着Nginx可以缓存从其他服务器接收的内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以下用例是使用Nginx作为缓存服务器的一些常见的用例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nginx可以位于Web服务器的前端，这可能是其他Nginx实例或Web应用程序。这是缓存服务器的典型用例 - 它作为其他Web或应用程序服务器的网关，起到了负载平衡器的作用。&lt;/li&gt;
  &lt;li&gt;Nginx缓存可以与负载均衡器一起使用。&lt;/li&gt;
  &lt;li&gt;实际上，Nginx可以充当负载平衡器和缓存服务器！&lt;/li&gt;
  &lt;li&gt;除了其他HTTP服务器/监听器之外，Nginx还可以缓存代理到FastCGI和uWSGI进程的请求结果！一个很好的用例是缓存内容管理系统（CMS）的结果，大多数用户不需要网站的动态方面 - 他们只是想看到内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;缓存服务器的主要优点&lt;/strong&gt;是我们在我们的应用服务器上放置的负载较少。对缓存的静态或动态资产的请求无需甚至到达应用程序（或静态内容）服务器 - 我们的缓存服务器本身可以处理许多请求！&lt;/p&gt;

&lt;p&gt;在这里的例子中，我们使用Nginx处理静态站点，再在前面放置Nginx缓存服务器。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;它如何工作&lt;/h1&gt;

&lt;p&gt;首先你需要知道Origin Server是什么。&lt;/p&gt;

&lt;p&gt;源服务器是拥有真正的静态文件或动态生成的HTML的服务器。他们有两个责任：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;请求时提供动态和静态内容&lt;/li&gt;
  &lt;li&gt;通过HTTP缓存头决定如何缓存文件（和潜在的动态内容）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来说下&lt;strong&gt;缓存服务器&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;缓存服务器（通常）是“前端”;它从客户端收到初始HTTP请求。然后它会处理请求本身（如果它具有所请求资源的新缓存副本），或者将请求传递给Origin Server来实现。&lt;/p&gt;

&lt;p&gt;如果请求发送到Origin Server，则由Cache Server读取源服务器的响应头，以确定响应是缓存还是简单传递。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一些较大的Web应用程序除了缓存服务器之外还使用负载平衡器，从而导致高度分层的基础架构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;缓存服务器的职责：
- 确定HTTP请求是否接受缓存响应，并且缓存中有一个新项目可以响应
- 如果请求不应被缓存，或者缓存的项目是否过期，则向源服务器发送HTTP请求
- 响应来自其缓存或源服务器的HTTP响应为适当的。&lt;/p&gt;

&lt;p&gt;最后说下&lt;strong&gt;客户端&lt;/strong&gt;。客户端可以拥有自己的本地（私有）缓存 - 例如每个浏览器都有一个本地缓存。我们的浏览器可能会缓存一个响应本身（通常是图像，CSS和JS文件），因此，如果静态文件在其本地缓存中已经有新版本，那么浏览器根本不会向缓存服务器发送请求。&lt;/p&gt;

&lt;p&gt;实现本地缓存的客户端具有以下职责：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发送请求&lt;/li&gt;
  &lt;li&gt;缓存响应&lt;/li&gt;
  &lt;li&gt;决定从本地缓存中提取请求或发出HTTP请求以检索它们&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section-2&quot;&gt;源服务器&lt;/h1&gt;

&lt;p&gt;源服务器最终负责提供文件和控制如何缓存文件。&lt;/p&gt;

&lt;p&gt;客户端可以请求不被缓存的资源。缓存服务器“必须”遵守HTTP规范。&lt;/p&gt;

&lt;p&gt;此外，客户端请求可缓存资源时，必须遵循从源服务器返回的缓存参数，这可能包括不缓存结果的指令！&lt;/p&gt;

&lt;p&gt;这意味着我们需要确定文件如何缓存在我们的源服务器上。 为此，我通常将&lt;a href=&quot;https://github.com/h5bp/server-configs-nginx/tree/master/h5bp&quot;&gt;H5BP配置目录&lt;/a&gt;复制到&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/nginx/h5bp&lt;/code&gt;,作为Nginx服务器配置。&lt;/p&gt;

&lt;p&gt;复制H5BP文件之后，我可以在源服务器的Nginx虚拟主机中包含&lt;code class=&quot;highlighter-rouge&quot;&gt;basic.conf&lt;/code&gt;配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    # Note that it's listening on port 9000
    listen 9000 default_server;
    root /var/www/;
    index index.html index.htm;

    server_name example.com www.example.com;

    charset utf-8;
    include h5bp/basic.conf;

    location / {
        try_files $uri $uri/ =404;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与缓存最相关的H5BP配置文件是&lt;code class=&quot;highlighter-rouge&quot;&gt;expires.conf&lt;/code&gt;，它确定了常见文件的缓存行为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Expire rules for static content

# cache.appcache, your document html and data
location ~* \.(?:manifest|appcache|html?|xml|json)$ {
  expires -1;
  # access_log logs/static.log; # I don't usually include a static log
}

# Feed
location ~* \.(?:rss|atom)$ {
  expires 1h;
  add_header Cache-Control &quot;public&quot;;
}

# Media: images, icons, video, audio, HTC
location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ {
  expires 1M;
  access_log off;
  add_header Cache-Control &quot;public&quot;;
}

# CSS and Javascript
location ~* \.(?:css|js)$ {
  expires 1y;
  access_log off;
  add_header Cache-Control &quot;public&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述配置禁用&lt;code class=&quot;highlighter-rouge&quot;&gt;manifest&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;appcache&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;html&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;文件的缓存。 它将&lt;code class=&quot;highlighter-rouge&quot;&gt;RSS&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ATOM&lt;/code&gt;订阅文件缓存1小时，&lt;code class=&quot;highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;CSS&lt;/code&gt;文件1年，以及其他静态文件（图像和媒体）1个月。&lt;/p&gt;

&lt;p&gt;缓存全部设置为“public”，所以任何系统都可以缓存它们。 将它们设置为私有将限制它们被私有缓存（例如我们的浏览器）缓存。&lt;/p&gt;

&lt;p&gt;所以源服务器本身没有进行任何缓存，只是说文件应该根据文件扩展名进行缓存。 H5BP为设置缓存规则提供了不错的参考。&lt;/p&gt;

&lt;p&gt;如果直接向源服务器发出请求，我们可以看到这些规则生效。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原始服务器我设置来测试这个恰好是运行在127.17.0.18:9000&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以&lt;code class=&quot;highlighter-rouge&quot;&gt;.html&lt;/code&gt;结尾的文件不会被缓存。 我们可以看到响应如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# GET curl request and select response headers
$ curl -X GET -I 127.17.0.18:9000/index.html
HTTP/1.1 200 OK
Server: nginx/1.4.6 (Ubuntu)
Date: Fri, 05 Sep 2014 23:24:52 GMT
Content-Type: text/html
Last-Modified: Fri, 05 Sep 2014 22:16:24 GMT
Expires: Fri, 05 Sep 2014 23:24:52 GMT
Cache-Control: no-cache
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;请注意，Expires与Date相同，表示该请求立即到期，即告诉客户端不要缓存。 响应还返回头信息&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control：no-cache&lt;/code&gt;来表明不缓存响应内容。 这完全遵循H5BP &lt;code class=&quot;highlighter-rouge&quot;&gt;expires.conf&lt;/code&gt;配置设置的&lt;code class=&quot;highlighter-rouge&quot;&gt;.html&lt;/code&gt;文件的规则。&lt;/p&gt;

&lt;p&gt;接下来，我们可以尝试获取一个需要缓存的文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# GET curl request and select response headers
$ curl -X GET -I 127.17.0.18:9000/css/style.css
HTTP/1.1 200 OK
Server: nginx/1.4.6 (Ubuntu)
Date: Fri, 05 Sep 2014 23:25:04 GMT
Content-Type: text/css
Last-Modified: Fri, 05 Sep 2014 22:46:39 GMT
Expires: Sat, 05 Sep 2015 23:25:04 GMT
Cache-Control: max-age=31536000
Cache-Control: public
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以看到这个css文件在当前日期的1年后过期！ 缓存规则的设置&lt;code class=&quot;highlighter-rouge&quot;&gt;max-age&lt;/code&gt;(过期时间）大约为1年（以秒为单位），并允许公共缓存。 这也遵循了H5BP &lt;code class=&quot;highlighter-rouge&quot;&gt;expires.conf&lt;/code&gt;里设置的&lt;code class=&quot;highlighter-rouge&quot;&gt;.css&lt;/code&gt;文件的规则。&lt;/p&gt;

&lt;p&gt;至此，源服务器设置好了。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;缓存服务器&lt;/h1&gt;

&lt;p&gt;源服务器已经设置完毕，但是我们需要在源服务器前面放置一个缓存服务器。 在我们的场景中，缓存服务器将作为Web服务器来接收请求。 如果缓存服务器不能直接从缓存里命中文件，则它会将HTTP请求传递给源服务器。&lt;/p&gt;

&lt;p&gt;在开始安装新的Nginx之前，我们可以先看一下反向代理的“标准”设置。以下设置尚未配置任何缓存，它只是实现将请求代理到源服务器的功能：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    # Note that it's listening on port 80
    listen 80 default_server;
    root /var/www/;
    index index.html index.htm;

    server_name example.com www.example.com;

    charset utf-8;

    location / {
        include proxy_params;
        proxy_pass http://172.17.0.18:9000;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;只是简单地将请求代理到源服务器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里为测试而设置的缓存服务器监听在&lt;code class=&quot;highlighter-rouge&quot;&gt;172.17.0.13:80&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果我们在缓存服务器上发出请求，就像直接发送请求到源服务器一样。 这是因为缓存服务器当前没有缓存：它只是将请求传递给源服务器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -X GET -I 172.17.0.13/css/style.css
HTTP/1.1 200 OK
Server: nginx/1.4.6 (Ubuntu)
Date: Fri, 05 Sep 2014 23:30:07 GMT
Content-Type: text/css
Last-Modified: Fri, 05 Sep 2014 22:46:39 GMT
Expires: Sat, 05 Sep 2015 23:30:07 GMT
Cache-Control: max-age=31536000
Cache-Control: public
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在，我们添加必要的指令，实现从源服务器中获取Nginx缓存响应。 我们在上面定义的配置中，增加额外的缓存指令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Note that these are defined outside of the server block,
# altho they don't necessarily need to be
proxy_cache_path /tmp/nginx levels=1:2 keys_zone=my_zone:10m inactive=60m;
proxy_cache_key &quot;$scheme$request_method$host$request_uri&quot;;

server {
    # Note that it's listening on port 80
    listen 80 default_server;
    root /var/www/;
    index index.html index.htm;

    server_name example.com www.example.com;

    charset utf-8;

    location / {
        proxy_cache my_zone;
        add_header X-Proxy-Cache $upstream_cache_status;

        include proxy_params;
        proxy_pass http://172.17.0.18:9000;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;以下解释一下缓存指令。&lt;/p&gt;

&lt;h2 id=&quot;proxycachepath&quot;&gt;proxy_cache_path&lt;/h2&gt;

&lt;p&gt;这是保存缓存文件的路径。 &lt;code class=&quot;highlighter-rouge&quot;&gt;levels&lt;/code&gt;指令设置缓存文件如何保存到文件系统。如果没有定义，缓存文件直接保存在指定的路径中。如果这样定义（&lt;code class=&quot;highlighter-rouge&quot;&gt;1：2&lt;/code&gt;），缓存文件将根据其md5哈希值保存在缓存路径的子目录中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;keys_zone&lt;/code&gt;是缓存区域的名称。这里它被命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;my_zone&lt;/code&gt;，并为缓存key和其他元数据提供了10MB的存储空间，尽管这并不限制可以缓存的文件数量！它只是设置元数据的存储空间。文档声称1MB区可以存储约8000个key和元数据。&lt;/p&gt;

&lt;p&gt;最后，我们设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;inactive&lt;/code&gt;指令，它告诉Nginx在60分钟内清除任何没有访问的缓存。请注意，这里&lt;code class=&quot;highlighter-rouge&quot;&gt;60m&lt;/code&gt;是60分钟，而&lt;code class=&quot;highlighter-rouge&quot;&gt;key_zone&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;10m&lt;/code&gt;是10兆字节。如果未显式设置，则&lt;code class=&quot;highlighter-rouge&quot;&gt;inactive&lt;/code&gt;指令默认为10分钟。&lt;/p&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;inactive&lt;/code&gt;使Nginx有机会“忘记”关于不常被请求的缓存资源。这样一来，Nginx缓存可以让您最大程度的降低成本 - 最需要的资源会保留在缓存中（并遵循愿服务器所指示的缓存规则）。&lt;/p&gt;

&lt;h2 id=&quot;proxycachekey&quot;&gt;proxy_cache_key&lt;/h2&gt;

&lt;p&gt;这是用来区分缓存文件的key。 默认值为&lt;code class=&quot;highlighter-rouge&quot;&gt;$scheme$proxy_host$uri$is_args$args&lt;/code&gt;，但是我们可以根据需要进行更改。&lt;/p&gt;

&lt;p&gt;proxy_cache_key也可以设置为类似&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$host$request_uri $cookie_user&quot;&lt;/code&gt;（带引号）这样的形式，也可以包括cookies信息。&lt;/p&gt;

&lt;p&gt;Cookie确实会影响缓存，所以请谨慎设置！ 如果Cookie被并入缓存密钥，您可能会意外地Nginx为每个独立cookie（每个站点访问者）都创建了重复缓存的文件。&lt;/p&gt;

&lt;p&gt;这意味着将Cookie并入key确实会降低缓存的有效性。 针对每个用户的缓存，是私有缓存（Web浏览器）的目的，而不是我们正在构建的“公共”缓存服务器的目的。 但是，在某种情景下确实需要引入Cookie，那么proxy_cache_key的这个选项就很有用了。&lt;/p&gt;

&lt;h2 id=&quot;proxycache&quot;&gt;proxy_cache&lt;/h2&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;location&lt;/code&gt;块内，Nginx以&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_cache my_zone&lt;/code&gt;指令定义缓存区域。&lt;/p&gt;

&lt;p&gt;我们还添加了一个有用的header（头信息）来通知我们资源是否从缓存提供。这可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_header X-Proxy-Cache $ upstream_cache_status&lt;/code&gt;指令完成。 这将设置一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;X-Proxy-Cache&lt;/code&gt;的响应头，值为&lt;code class=&quot;highlighter-rouge&quot;&gt;HIT&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;MISS&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;BYPASS&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;保存配置文件后，重新加载Nginx的配置（&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo service nginx reload&lt;/code&gt;），并再次尝试HTTP请求。&lt;/p&gt;

&lt;p&gt;首次获取CSS文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# GET curl request and selected headers
$ curl -X GET -I 172.17.0.13/css/style.css
Date: Fri, 05 Sep 2014 23:50:12 GMT
Content-Type: text/css
Last-Modified: Fri, 05 Sep 2014 22:46:39 GMT
Expires: Sat, 05 Sep 2015 23:50:12 GMT
Cache-Control: max-age=31536000
Cache-Control: public
X-Proxy-Cache: MISS
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为之前没有请求过该文件，所以这里返回的cache状态为MISS。缓存服务器需要向源服务器请求资源。
再试一次：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# GET curl request and selected headers
$ curl -X GET -I 172.17.0.13/css/style.css
Date: Fri, 05 Sep 2014 23:50:48 GMT
Content-Type: text/css
Last-Modified: Fri, 05 Sep 2014 22:46:39 GMT
Expires: Sat, 05 Sep 2015 23:50:12 GMT
Cache-Control: max-age=31536000
Cache-Control: public
X-Proxy-Cache: HIT
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以看到，第二个请求和第一个请求相差不到30秒。 我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;X-Proxy-Cache&lt;/code&gt;头信息看到缓存状态是&lt;code class=&quot;highlighter-rouge&quot;&gt;HIT&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires&lt;/code&gt;头信息保持不变，因为Nginx只是从缓存中返回资源。 当缓存服务器返回到源服务器获取新文件时，那些头信息将会更新。&lt;/p&gt;

&lt;p&gt;安装现在的设置，Nginx将忽略客户端的&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control&lt;/code&gt;请求头。 但是，有些Web客户端不想使用缓存项目，我们希望缓存服务器能够支持这种要求。&lt;/p&gt;

&lt;p&gt;例如，使用浏览器打开网页时，按住SHIFT，同时单击重新加载按钮，这时浏览器将发送一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control: no-cache&lt;/code&gt;。 这要求缓存服务器不提供资源的缓存版本。 但目前我们的设置会将之忽略。&lt;/p&gt;

&lt;p&gt;为了在请求时适当地绕过缓存，我们可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;location&lt;/code&gt;块中将&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_cache_bypass $http_cache_control&lt;/code&gt;指令添加到缓存服务器中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location / {
    proxy_cache my_zone;
    proxy_cache_bypass  $http_cache_control;
    add_header X-Proxy-Cache $upstream_cache_status;

    include proxy_params;
    proxy_pass http://172.17.0.18:9000;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;nginx reload 之后，可以看到设置生效了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -X GET -I 172.17.0.13/css/style.css
...
X-Proxy-Cache: HIT     # A regular request which is normally a cache HIT ...

$ curl -X GET -I -H &quot;Cache-Control: no-cache&quot; 172.17.0.13/css/style.css
...
X-Proxy-Cache: BYPASS  # ... is now bypassed when told to
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_cache_bypass&lt;/code&gt;指令告知Nginx遵守HTTP请求中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control&lt;/code&gt;请求头。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;代理缓存&lt;/h1&gt;

&lt;p&gt;Nginx的缓存功能强大！ 我们刚刚看到它可以缓存代理的HTTP请求，但是它也可以缓存FastCGI，uWSGI代理请求的结果，甚至缓存负载平衡请求（“upstream”）的结果。 这意味着我们可以缓存到动态应用程序的请求结果。&lt;/p&gt;

&lt;p&gt;如果我们使用Nginx来缓存FastCGI进程的结果，我们可以将FastCGI进程视为源服务器，将Nginx作为缓存服务器。 例如，在&lt;code class=&quot;highlighter-rouge&quot;&gt;fideloper.com&lt;/code&gt;上，我缓存了从PHP-FPM返回的HTML结果。&lt;/p&gt;

&lt;p&gt;这是一个使用&lt;code class=&quot;highlighter-rouge&quot;&gt;fastcgi_cache&lt;/code&gt;的示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fastcgi_cache_path /tmp/cache levels=1:2 keys_zone=fideloper:100m inactive=60m;
fastcgi_cache_key &quot;$scheme$request_method$host$request_uri&quot;;

server {

    # Boilerplay omitted

    set $no_cache 0;

    # Example: Don't cache admin area
    # Note: Conditionals are typically frowned upon :/
    if ($request_uri ~* &quot;/(admin/)&quot;)
    {
        set $no_cache 1;
    }

    location ~ ^/(index)\.php(/|$) {
            fastcgi_cache fideloper;
            fastcgi_cache_valid 200 60m; # Only cache 200 responses, cache for 60 minutes
            fastcgi_cache_methods GET HEAD; # Only GET and HEAD methods apply
            add_header X-Fastcgi-Cache $upstream_cache_status;
            fastcgi_cache_bypass $no_cache;  # Don't pull from cache based on $no_cache
            fastcgi_no_cache $no_cache; # Don't save to cache based on $no_cache

            # Regular PHP-FPM stuff:
            include fastcgi.conf; # fastcgi_params for nginx &amp;lt; 1.6.1
            fastcgi_split_path_info ^(.+\.php)(/.+)$;
            fastcgi_pass unix:/var/run/php5-fpm.sock;
            fastcgi_index index.php;
            fastcgi_param LARA_ENV production;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的缓存设置选项很多。对于使用FastCGI缓存，请注意以下两点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;fastcgi_cache&lt;/code&gt;替换proxy_cache的所有实例&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;fastcgi_cache_valid 200 60m&lt;/code&gt;来设置PHP请求响应的到期时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你可以看到实际效果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -X GET -I fideloper.com/index.php
...
Cache-Control: max-age=86400, public
X-Fastcgi-Cache: MISS

$ curl -X GET -I fideloper.com/index.php
...
X-Fastcgi-Cache: HIT

# If this URL existed, you'd see a BYPASS
$ curl -X GET -I fideloper.com/admin
...
X-Fastcgi-Cache: BYPASS
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;section-5&quot;&gt;相关资源&lt;/h1&gt;

&lt;p&gt;您可以使用缓存进行更多的操作，例如设置不进行缓存的情况（例如管理区域）以及清除缓存的方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.mnot.net/cache_docs/&quot;&gt;Learn about Web Caches&lt;/a&gt; , 作者是Mark Nottingham，IETF组织HTTP工作组主席，W3C技术架构组的成员。 建议所有网站开发者都阅读。还有 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616.html&quot;&gt;HTTP Specification&lt;/a&gt; 也很有参考价值。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.com/resources/admin-guide/caching/&quot;&gt;Nginx Admin Guide on Caching&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;HTTP Cache Docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;FastCGI Cache docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html&quot;&gt;uWSGI Cache Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;本文翻译自&lt;a href=&quot;https://serversforhackers.com/nginx-caching&quot;&gt;Nginx Caching&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&quot;https://translate.google.com&quot;&gt;谷歌翻译&lt;/a&gt;，它出色的效果减少了博主很多工作量。&lt;/p&gt;
</description>
                <link>http://spetacular.github.io/2017/04/10/nginx-cache.html</link>
                <guid>http://spetacular.github.io/2017/04/10/nginx-cache</guid>
                <pubDate>Mon, 10 Apr 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Editor.md开源在线 Markdown 编辑器增加本地自动保存功能</title>
                <description>&lt;p&gt;&lt;a href=&quot;http://pandao.github.io/editor.md/&quot;&gt;Editor.md&lt;/a&gt; 是一款开源 Markdown 在线编辑器。在编辑较长文章时，为防止疏忽造成内容丢失，可以添加自动保存功能。&lt;/p&gt;

&lt;p&gt;预览地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.text.wiki/md/&quot;&gt;https://www.text.wiki/md/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;利用localStorage来暂存数据。当文本框有改动时，将内容存到localStorage里；当页面再次加载时，读取localStorage的值。&lt;/p&gt;

&lt;p&gt;假设页面创建的编辑器命名为 mdEditor ,则只需将以下js加入页面即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    var key = 'default_md_key';
    mdEditor.on(&quot;load&quot;, function(){
        var content = localStorage.getItem(key);
        if(content){
            var f = confirm(&quot;您上次编辑的文章未提交，是否恢复？内容：\n&quot;+content);
            if(f == true){
                testEditor.setValue(content)
            }
        }
    })

    mdEditor.on(&quot;change&quot;, function(){
        localStorage.setItem(key,this.getValue())
    })
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用户向服务器提交数据并保存成功后，可以删掉key。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;localStorage.removeItem(key);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
                <link>http://spetacular.github.io/2017/04/07/editor-md-auto-save-markdown.html</link>
                <guid>http://spetacular.github.io/2017/04/07/editor-md-auto-save-markdown</guid>
                <pubDate>Fri, 07 Apr 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>小程序新能力：公众号自定义菜单点击打开相关小程序</title>
                <description>&lt;p&gt;微信在2017年3月27日发布了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDAwMTA2MA==&amp;amp;mid=2695729676&amp;amp;idx=1&amp;amp;sn=2f0279377bcc6b0ea14d30389dfde698&amp;amp;chksm=83d74bc7b4a0c2d197ebad8e77b4e6a3f5c19a6ef91f0602b4a695d2ef0994fd1e6431a5babb&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0327yIBkOfW0f1CEF7Sc1MY2#rd&quot;&gt;《小程序新能力》&lt;/a&gt;的重要更新，主要新增了以下功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;个人开发者可申请小程序&lt;/li&gt;
  &lt;li&gt;公众号自定义菜单点击可打开相关小程序&lt;/li&gt;
  &lt;li&gt;公众号模版消息可打开相关小程序&lt;/li&gt;
  &lt;li&gt;公众号关联小程序时，可选择给粉丝下发通知&lt;/li&gt;
  &lt;li&gt;移动App可分享小程序页面&lt;/li&gt;
  &lt;li&gt;扫描普通链接二维码可打开小程序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文主要说明实现公众号自定义菜单点击打开相关小程序。&lt;/p&gt;

&lt;p&gt;公众号可将已关联的小程序页面放置到自定义菜单中，用户点击后可打开该小程序页面。公众号运营者可在公众平台进行设置，也可以通过自定义菜单接口进行设置。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;1.公众平台设置方式&lt;/h1&gt;
&lt;p&gt;## 1.1关联小程序&lt;/p&gt;

&lt;p&gt;当读者使用公众平台设置方式时，首先要关联公众号和小程序。打开公众平台https://mp.weixin.qq.com，打开“设置” –&amp;gt; “公众号设置”，可以看到如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/mp-add-relative-minapp.png&quot; alt=&quot;公众平台公众号设置，关联小程序&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击“添加”按钮，即进入小程序添加页面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/mp-add-relative-minapp-2.png&quot; alt=&quot;公众平台公众号设置，关联小程序&quot; /&gt;&lt;/p&gt;

&lt;p&gt;扫码验证身份后，即可关联小程序。再输入框输入小程序的AppID，点击搜索按钮，即可完成关联。&lt;/p&gt;

&lt;p&gt;注意，只能关联公众号主体一致的小程序。就是说，公共号和小程序的主体如果是个人，则必须是同一个人；如果是企业，则必须是同一企业。&lt;/p&gt;

&lt;p&gt;公众号关联小程序时，可勾选“关联后给已关注公众号的用户发送通知”，给粉丝下发通知消息，粉丝点击该通知消息可以打开小程序。该消息不占用原有群发条数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/mp-add-relative-minapp-3.png&quot; alt=&quot;公众平台公众号设置，关联小程序&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1.2设置小程序自定义菜单&lt;/h2&gt;

&lt;p&gt;可以在“功能管理”下“自定义菜单”下编辑，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/mp-add-relative-minapp-4.png&quot; alt=&quot;公众平台公众号设置，关联小程序&quot; /&gt;&lt;/p&gt;

&lt;p&gt;填写要素有：&lt;/p&gt;

&lt;p&gt;1.菜单名称：底部自定义菜单展示的文字；&lt;/p&gt;

&lt;p&gt;2.跳转类型：选择“跳转小程序”Tab；&lt;/p&gt;

&lt;p&gt;3.小程序路径：填入小程序路径&lt;/p&gt;

&lt;p&gt;4.备用网页：旧版兼容选项。旧版微信客户端无法支持小程序时，用户点击菜单时将会打开备用网页。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;2.开发模式自定义菜单创建&lt;/h1&gt;

&lt;p&gt;在开发模式下，可以通过自定义菜单创建接口来创建小程序的菜单。文档地址为&lt;a href=&quot;https://mp.weixin.qq.com/wiki&quot;&gt;https://mp.weixin.qq.com/wiki&lt;/a&gt;下的“自定义菜单”页面。&lt;/p&gt;

&lt;p&gt;接口地址如下：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN
&lt;/code&gt;
请求内容示例如下：
&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;button&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;miniprogram&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;小程序&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;appid&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;wx1dda1f639e823874&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://www.qq.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;pagepath&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;page/index&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;
完整程序如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
define('APPID', '公众号APPID ');//公众号APPID
define('APPSECRET', '公众号APPSECRET ');//公众号APPSECRET
//$menu变量为存放菜单项的json字符串
$menu =
	'{
&quot;button&quot;: [
{
&quot;type&quot;: &quot;miniprogram&quot;,
&quot;name&quot;: &quot;小程序&quot;,
&quot;appid&quot;: &quot;请填写小程序ID&quot;,
&quot;url&quot;: &quot;http://www.qq.com&quot;,
&quot;pagepath&quot;: &quot;page/index&quot;
}
]
}';
$url = &quot;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&quot; . get_token();
$content = curl_post($url, $menu);
$ret = json_decode($content, true);
if ($ret['errcode'] == 0) {//创建成功
	echo 'create menu ok';
} else {//创建失败
	echo 'create menu fail,msg:' . $ret['errmsg'];
}
function curl_post($url, $post_string) {
	$ch = curl_init();
	curl_setopt($ch, CURLOPT_URL, $url);
	curl_setopt($ch, CURLOPT_POSTFIELDS, $post_string);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
	$data = curl_exec($ch);
	curl_close($ch);
	return $data;
}
function curl_get($url) {
	$ch = curl_init();
	curl_setopt($ch, CURLOPT_URL, $url);;
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
	curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
	curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);
	if (!curl_exec($ch)) {
		$data = '';
	} else {
		$data = curl_multi_getcontent($ch);
	}
	curl_close($ch);
	return $data;
}
function get_token() {
	$url = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid=&quot; . APPID . &quot;&amp;amp;secret=&quot; . APPSECRET;
	$content = curl_get($url);
	$ret = json_decode($content, true);//{&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200}
	if (array_key_exists('errcode', $ret) &amp;amp;&amp;amp; $ret['errcode'] != 0) {
		return false;
	} else {
		return $ret['access_token'];
	}
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;section-3&quot;&gt;欢迎加入微信开发者小密圈&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;微信开放平台拥有订阅号、服务号、小程序和企业号，吸引了一大批开发者，也形成了独特的生态圈。希望我们能吸收能量，交换信息，自由生长。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PC端点击链接：&lt;a href=&quot;https://wx.xiaomiquan.com/mweb/views/joingroup/join_group.html?group_id=4221251218&amp;amp;secret=7hrxv8fo5gg7qnjagobezs1g05wsus91&amp;amp;extra=03805215ea752e7e60e44178c4f4f15003ec659aa155aacda4ae846184cea8fe&quot;&gt;微信生态圈小密圈&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;微信扫码：
&lt;img src=&quot;http://wx4.sinaimg.cn/large/7ed0a961ly1fdb80fejqmj20k20u8diq.jpg&quot; alt=&quot;微信生态圈&quot; /&gt;&lt;/p&gt;
</description>
                <link>http://spetacular.github.io/2017/03/31/weixin-mp-open-minapp-in-menu.html</link>
                <guid>http://spetacular.github.io/2017/03/31/weixin-mp-open-minapp-in-menu</guid>
                <pubDate>Fri, 31 Mar 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>教程：配置 Let's Encrypt 免费HTTPS证书</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;目录定义&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;存放验证域名的文件，即acme-dir，默认存储在/home/xxx/www/challenges/&lt;/li&gt;
  &lt;li&gt;存放最终结果证书的目录，如本文中的/data/ssl&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;存放验证域名文件的目录&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     mkdir ~/www/challenges/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后配置一个 HTTP 服务，以 Nginx 为例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NGINX
    server {
        server_name www.yoursite.com yoursite.com;

        location ^~ /.well-known/acme-challenge/ {
            alias /home/xxx/www/challenges/;
            try_files $uri =404;
        }

        location / {
            rewrite ^/(.*)$ https://yoursite.com/$1 permanent;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后重启nginx。
&lt;code class=&quot;highlighter-rouge&quot;&gt; 
 sudo service nginx reload
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;创建存放证书的目录&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mkdir /data/ssl
    cd /data/ssl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;rsa--lets-encrypt-&quot;&gt;创建一个 RSA 私钥用于 Let’s Encrypt 识别你的身份&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    openssl genrsa 4096 &amp;gt; account.key
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;rsa-&quot;&gt;创建 RSA 私钥（兼容性好）&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    openssl genrsa 4096 &amp;gt; domain.key
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;common-name-&quot;&gt;Common Name 必须为你的域名，其它的随便填&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    openssl req -new -sha256 -key domain.key -out domain.csr
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;获取脚本&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;csr-&quot;&gt;指定账户私钥、CSR 以及验证目录，执行脚本：&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /home/xxx/www/challenges/ &amp;gt; ./signed.crt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果一切正常，当前目录下就会生成一个 signed.crt，这就是申请好的证书文件。
## 证书融合&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &amp;gt; intermediate.pem
cat signed.crt intermediate.pem &amp;gt; chained.pem
    wget -O - https://letsencrypt.org/certs/isrgrootx1.pem &amp;gt; root.pem
cat intermediate.pem root.pem &amp;gt; full_chained.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;ssl&quot;&gt;ssl配置&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    server {
        listen 443;
        server_name www.text.wiki;
        root   /data/htdocs/textwiki;
        autoindex on;
        index index.php index.html;
        ssl on;
        ssl_certificate /data/ssl/chained.pem;
        ssl_certificate_key /data/ssl/domain.key;
        ssl_protocols              TLSv1 TLSv1.1 TLSv1.2;
        ssl_trusted_certificate    /data/ssl/full_chained.pem;

        location / {
                    try_files $uri $uri/ /index.php;

                    location ~ \.php$ {
                        fastcgi_pass unix:/var/run/php5-fpm.sock;
                        fastcgi_param  SCRIPT_FILENAME /data/htdocs/textwiki$fastcgi_script_name;
                        include        fastcgi_params;
                    }
                }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;自动更新脚本&lt;/h2&gt;
&lt;p&gt;1.新建文件&lt;code class=&quot;highlighter-rouge&quot;&gt;vi renew_cert.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.填写如下内容&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
    cd /data/ssl/
    python acme_tiny.py --account-key account.key --csr domain.csr --acme-dir /home/xxx/www/challenges/ &amp;gt; signed.crt &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;exit
    &lt;/span&gt;wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &amp;gt; intermediate.pem
    cat signed.crt intermediate.pem &amp;gt; chained.pem
    wget -O - https://letsencrypt.org/certs/isrgrootx1.pem &amp;gt; root.pem
cat intermediate.pem root.pem &amp;gt; full_chained.pem
    service nginx reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;3.&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod +x renew_cert.sh&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;crontab&quot;&gt;加入crontab&lt;/h2&gt;

&lt;p&gt;crontab 中加入自动更新脚本，每月自动更新，crontab -e 加入以下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    0 0 1 * * /data/ssl/renew_cert.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-5&quot;&gt;最关键的是，如果服务器有防火墙，请放开服务器的443入口&lt;/h2&gt;

&lt;h2 id=&quot;section-6&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;本文注重实战，跟着教程一步一步配置即可，想了解原理的同学，可以参考如下网址：   &lt;br /&gt;
&lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt官网&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;https://imququ.com/post/letsencrypt-certificate.html&quot;&gt;Let’s Encrypt，免费好用的 HTTPS 证书&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;https://ksmx.me/letsencrypt-ssl-https/&quot;&gt;Let’s Encrypt 给网站加 HTTPS 完全指南&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://spetacular.github.io/2017/03/29/lets-encrypt-deploy-step-by-step.html</link>
                <guid>http://spetacular.github.io/2017/03/29/lets-encrypt-deploy-step-by-step</guid>
                <pubDate>Wed, 29 Mar 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Docker:网络配置</title>
                <description>&lt;p&gt;Docker运行容器时，一个常见的问题是：localhost(127.0.0.1)指向哪里？这涉及到Docker的网络配置问题。&lt;/p&gt;

&lt;!-- Docker 一个常用用法是开放特定端口来对外提供服务，如 Mysql 占用3306端口，redis 占用 6379 端口。这样就牵扯到网络配置的问题（以 Mysql 为例）：    
1. localhost(127.0.0.1)指向哪里？     
2. [宿主机](/2017/03/10/docker-basic-concept.html#host)如何连接到Mysql服务所在的容器？   
3. 另一台运行在容器内的php服务如何连接到 Mysql 服务器所在的容器？ --&gt;

&lt;p&gt;Docker支持的网络模式如下：bridge（默认）、host、container、network-name、none。&lt;/p&gt;

&lt;h1 id=&quot;bridge&quot;&gt;桥接 bridge&lt;/h1&gt;
&lt;p&gt;Docker 默认的网络模式是 bridge 。在该模式下，docker 创建了一个 bridge，名称通常为 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt; 。 &lt;br /&gt;
可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;ifconfig&lt;/code&gt;来查看：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
docker0   Link encap:Ethernet  HWaddr **:**:**:**:**:**
          inet addr:192.168.0.1  Bcast:0.0.0.0  Mask:255.255.240.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:305002 errors:0 dropped:0 overruns:0 frame:0
          TX packets:407006 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:30331811 (30.3 MB)  TX bytes:752905683 (752.9 MB)
&lt;/code&gt;
宿主机和容器通过bridge进行通信，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/docker-networking-bridge-mode.jpeg&quot; alt=&quot;docker桥接bridge模式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;容器内的localhost指向容器内部。&lt;/p&gt;

&lt;h1 id=&quot;host&quot;&gt;本机 host&lt;/h1&gt;
&lt;p&gt;当使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--net=host&lt;/code&gt;启动容器时，网络配置为 host 模式。该模式下，容器和宿主机共享网络。形象地讲，容器和宿主机共享一个网卡，在容器内的网络访问如同直接在宿主机上操作一样。例如：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
docker run --rm -it --net=host ubuntu:trusty bash
&lt;/code&gt;
容器内的localhost指向宿主机。
&lt;img src=&quot;/images/2016/docker-networking-host-mode.jpeg&quot; alt=&quot;docker桥接host模式&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;container&quot;&gt;container&lt;/h1&gt;
&lt;p&gt;Docker可以指定一个容器复用另一个容器的网络设置。这种模式适用于由多个容器搭建整套系统的情况，例如搭建PHP开发环境时，希望Mysql、Redis都使用PHP容器的网络配置，即可以使用该模式。&lt;/p&gt;

&lt;h1 id=&quot;network-name&quot;&gt;network-name&lt;/h1&gt;
&lt;p&gt;Docker允许用户使用Docker network driver或[第三方network driver插件]（https://docs.docker.com/engine/extend/legacy_plugins/#network-plugins）创建自定义网络，然后多个容器都可以使用相同的网络。常见的第三方etwork driver插件有：&lt;a href=&quot;https://github.com/contiv/netplugin&quot;&gt;Contiv Networking&lt;/a&gt;、&lt;a href=&quot;https://github.com/openstack/kuryr&quot;&gt;Kuryr Network Plugin&lt;/a&gt;、&lt;a href=&quot;https://www.weave.works/docs/net/latest/introducing-weave/&quot;&gt;Weave Network Plugin&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;none&quot;&gt;none&lt;/h1&gt;
&lt;p&gt;顾名思义，该模式下没有网络连接。例如我的宿主机ip为192.168.0.59，在容器内访问宿主机就提示无网络。
&lt;code class=&quot;highlighter-rouge&quot;&gt;
docker run -it --net=none my_ubuntu bash
root@6533968160dd:/# ping 192.168.0.59
connect: Network is unreachable
&lt;/code&gt;&lt;/p&gt;

&lt;!-- # Docker为什么没有 nat 模式 --&gt;
</description>
                <link>http://spetacular.github.io/2017/03/20/docker-network-settings.html</link>
                <guid>http://spetacular.github.io/2017/03/20/docker-network-settings</guid>
                <pubDate>Mon, 20 Mar 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Docker:基本概念</title>
                <description>&lt;h1 id=&quot;image&quot;&gt;&lt;a href=&quot;#image&quot;&gt;镜像&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Docker镜像Image是一个就像具有&lt;a href=&quot;https://zh.wikipedia.org/wiki/Time_Machine&quot;&gt;Time Machine&lt;/a&gt;功能的虚拟机，保存着特定时刻的一个快照。这个快照包含了已安装的程序、共享库、配置文件、环境变量、用户组等信息。构建Image时，以上内容不会改变。这意味着可以利用Image快速复制出多个相同的运行实体（容器）。&lt;/p&gt;

&lt;h1 id=&quot;container&quot;&gt;&lt;a href=&quot;#container&quot;&gt;容器&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Docker容器container是镜像Image的运行实体。一个镜像可以生成多个相同的容器，每个容器的代码、运行环境、系统工具、系统库都完全相同。这在环境部署、服务扩容等方面具有重大作用。&lt;/p&gt;

&lt;h1 id=&quot;registry&quot;&gt;&lt;a href=&quot;#registry&quot;&gt;仓库&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Docker仓库Registry是一个镜像存储和分发的服务。一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。&lt;/p&gt;

&lt;h1 id=&quot;build&quot;&gt;&lt;a href=&quot;#build&quot;&gt;构建&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;利用 &lt;a href=&quot;https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#run&quot;&gt;Dockerfile&lt;/a&gt; 定制镜像时，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;docker build&lt;/code&gt;命令，将指令构建为文件系统。&lt;/p&gt;

&lt;h1 id=&quot;host&quot;&gt;&lt;a href=&quot;#host&quot;&gt;宿主机&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;宿主机就是运行Docker容器的机器。例如我在mac上用&lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker for Mac&lt;/a&gt;，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;docker pull ubuntu&lt;/code&gt;来拉取一个ubuntu镜像然后运行，那么宿主机指的是mac。&lt;/p&gt;
</description>
                <link>http://spetacular.github.io/2017/03/10/docker-basic-concept.html</link>
                <guid>http://spetacular.github.io/2017/03/10/docker-basic-concept</guid>
                <pubDate>Fri, 10 Mar 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>PHP异步任务队列管理器asyntask介绍</title>
                <description>&lt;h1 id=&quot;phpasyntask&quot;&gt;PHP异步任务队列管理器asyntask&lt;/h1&gt;
&lt;p&gt;asyntask是一个轻量级异步任务队列管理器，支持实时，定时，长时和周期任务。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;项目由来&lt;/h2&gt;

&lt;p&gt;本项目最初用于通知推送。例如用户发布评论，需要推送一条push给原作者。而到苹果的服务器的请求时间较长，如果等待苹果服务器的返回结果，则整个发布评论的接口的响应时间就太长了。因为推送push早1秒晚1秒对用户基本没影响，所以当用户发布评论时，只要数据到数据库，即可返回。与此同时创建一条异步任务，在1秒内给用户推送push。这样既保证了接口的响应速度，又不影响用户体验。该项目已经在线上环境运行1年多，执行了累计8千万条命令，运行稳定。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;优点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;异步执行&lt;/li&gt;
  &lt;li&gt;集成管理后台，可视化操作&lt;/li&gt;
  &lt;li&gt;代码集成，可编程&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;缺点&lt;/h2&gt;

&lt;p&gt;并非真正实时，秒级误差。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;安装&lt;/h1&gt;
&lt;p&gt;## 下载源码&lt;/p&gt;

&lt;p&gt;直接使用：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
git clone https://github.com/spetacular/asyntask.git
&lt;/code&gt;
命令下载到本地。&lt;/p&gt;

&lt;p&gt;也可以点击 &lt;a href=&quot;https://github.com/spetacular/asyntask/archive/master.zip&quot;&gt;https://github.com/spetacular/asyntask/archive/master.zip&lt;/a&gt; 下载最新内容的压缩包，然后解压。
## 通过 composer 来安装&lt;/p&gt;

&lt;p&gt;在你的 composer 项目中的 composer.json 文件中，添加这部分：
&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;require&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
           &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;davidyan/asyntask&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;gt;=1.0&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;composer install&lt;/code&gt;。调用示例如下：
```
include ‘./vendor/autoload.php’;
$task = new AsynTask\Task();&lt;/p&gt;

&lt;p&gt;//添加单次任务
$name = ‘单次任务’;
$cmd = ‘php abcd.php’;
$params = array(
	‘params’=&amp;gt;1
);
$task-&amp;gt;add_once_task($name,$cmd,$params);
```&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;配置&lt;/h1&gt;
&lt;p&gt;1.asyntask的数据默认存储在Mysql数据库里，因此需要更改config.php里的配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	'DB_HOST'=&amp;gt;'127.0.0.1',
	'DB_NAME' =&amp;gt; 'asyntask',
	'DB_USER' =&amp;gt; 'root',
	'DB_PWD' =&amp;gt; '',
	'DB_PORT' =&amp;gt; '3306',
	'DB_CHARSET' =&amp;gt; 'utf8mb4',
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.导入数据表
将resource文件夹里的db.sql导入数据库中。&lt;/p&gt;

&lt;p&gt;3.配置健康检查脚本
run.sh定期检查异步任务的运行状况，如果挂了，cron_asyn_task.php脚本。
&lt;code class=&quot;highlighter-rouge&quot;&gt;
chmod +x run.sh
&lt;/code&gt;
然后配置CronTab。运行&lt;code class=&quot;highlighter-rouge&quot;&gt;crontab -e&lt;/code&gt;，然后添加一行：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
* * * * *  path-to/run.sh  &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;
# 使用方式&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;管理后台&lt;/h2&gt;

&lt;p&gt;自带管理后台，可以轻松添加、编辑、删除、搜索任务。代码在&lt;a href=&quot;https://github.com/spetacular/asynadmin&quot;&gt;https://github.com/spetacular/asynadmin&lt;/a&gt;，请自行部署。
&lt;a href=&quot;https://github.com/spetacular/asynadmin/raw/master/asynadmin.jpeg&quot;&gt;&lt;img src=&quot;https://github.com/spetacular/asynadmin/raw/master/asynadmin.jpeg&quot; alt=&quot;管理后台截图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;编程方式&lt;/h2&gt;

&lt;p&gt;可以集成到项目中，完整使用示例见&lt;code class=&quot;highlighter-rouge&quot;&gt;test.php&lt;/code&gt;。
例如添加周期任务：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
$name = '周期任务';
$cmd = 'php abc.php';
$params = array(
	'params'=&amp;gt;1
);
$timeOptions = array(
	'day'=&amp;gt;1,
	'hour'=&amp;gt;2,
	'minute'=&amp;gt;3
);
$task-&amp;gt;add_loop_task($name,$cmd,$params,$timeOptions);
&lt;/code&gt;
## 周期任务示例&lt;/p&gt;

&lt;p&gt;每天执行：day 1 hour 0 minute 0 每天零点执行&lt;/p&gt;

&lt;p&gt;每小时执行：day 0 hour 1 minute 5 每小时的5分执行&lt;/p&gt;

&lt;p&gt;每隔若干分钟执行：day 0 hour 0 minute 5 每隔5分钟执行&lt;/p&gt;
</description>
                <link>http://spetacular.github.io/2017/03/09/asyntask-desc.html</link>
                <guid>http://spetacular.github.io/2017/03/09/asyntask-desc</guid>
                <pubDate>Thu, 09 Mar 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>开发知识点记录</title>
                <description>&lt;h1 id=&quot;cron-&quot;&gt;cron 任务没执行的原因&lt;/h1&gt;

&lt;p&gt;查看 cron 日志，日志路径一般在：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/var/log/cron.log
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/var/log/syslog
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就能看到类似这样的错误：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Error: bad username; while reading /etc/crontab
(&lt;em&gt;system&lt;/em&gt;) ERROR (Syntax error, this crontab file will be ignored)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后按图索骥，查找失败原因。&lt;/p&gt;

&lt;h1 id=&quot;cron--1&quot;&gt;cron 启动、关闭、重启、重载、查看服务状态&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	service cron start    //启动服务
　　	service cron stop     //关闭服务
　　	service cron restart  //重启服务
　　	service cron reload   //重新载入配置
　　	service cron status   //查看服务状态 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;section&quot;&gt;命令行输错命令如何快速撤销？&lt;/h1&gt;
&lt;p&gt;最笨的方法可以按删除键，一个一个删除；
&lt;img src=&quot;/images/2016/withdraw-input-1.gif&quot; alt=&quot;撤销命令&quot; /&gt;
最快的办法是Ctrl + U，一键清理。
&lt;img src=&quot;/images/2016/withdraw-input-2.gif&quot; alt=&quot;撤销命令&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;dockercontainer-cmd&quot;&gt;docker显示容器命令(container CMD)详情&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker inspect  -f &quot; &quot; $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;# php生成形容’HH:MM:SS’格式的时间
&lt;code class=&quot;highlighter-rouge&quot;&gt;
gmstrftime('%H:%M:%S',$time)
&lt;/code&gt;
例如
&lt;code class=&quot;highlighter-rouge&quot;&gt;
echo gmstrftime('%H:%M:%S',3786);
//Output: 01:03:06
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;chrome-&quot;&gt;chrome 下上传图片/文件慢的解决办法&lt;/h1&gt;

&lt;p&gt;最近用flow.js做的上传图片功能，突然变得很慢，要10秒左右才能打开上传对话框。查了一下，是mac chrome的一个bug。设置图片格式时，如果采用如下写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input type=&quot;file&quot; accept=&quot;image/*&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;则会重现。有网友反映，windows 10, chrome 53下也会有此问题。解决办法是，将image/*换为具体的格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input type=&quot;file&quot; accept=&quot;image/png, image/jpeg, image/gif&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://stackoverflow.com/questions/39187857/inputfile-accept-image-open-dialog-so-slow-with-chrome&quot;&gt;open dialog so slow with Chrome&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://spetacular.github.io/2017/01/01/develop-tips.html</link>
                <guid>http://spetacular.github.io/2017/01/01/develop-tips</guid>
                <pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Restful API中的JSON模板解析－JSONOut库的介绍</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;项目地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spetacular/jsonout&quot;&gt;Restful API中的JSON模板解析&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;json&quot;&gt;为什么需要JSON模板解析&lt;/h2&gt;

&lt;p&gt;Restful API的两个重要因素是输入和输出，一个好的API要求输入和输出都清晰可见。
输入包括用户提交的方式、参数等，都是可预期的。尽量不要采用数组接收。例如以下的例子，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$data = $_POST;
$User-&amp;gt;save($data);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的坏处一是无法过滤用户非法、多余的参数提交；二是参数不明，后续无法维护。&lt;/p&gt;

&lt;p&gt;输出则要求仅提供满足需要的最小的数据集。例如如下的例子，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$user = User::get(1);
echo $user-&amp;gt;toJson();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的坏处一是输出的内容不清晰，只有知道数据表的结构才能了解输出的内容；二是可能一不小心把用户表敏感字段（密码，手机号）输出，造成信息泄漏。&lt;/p&gt;

&lt;h2 id=&quot;jsonout&quot;&gt;JSONOut库介绍&lt;/h2&gt;

&lt;p&gt;解决输出的方法，是采用JSON模板解析的方法。例如用户表有id,name,pass,avatar,phone字段，其中只有name,avatar是需要输出的。那么模板可以这样定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;avatar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当输出用户数据时，仅保留name和avatar，其它字段自动过滤掉。&lt;/p&gt;

&lt;p&gt;优点是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输出结构一目了然&lt;/li&gt;
  &lt;li&gt;仅保留满足需要的最小的数据集&lt;/li&gt;
  &lt;li&gt;敏感字段自动过滤，减少信息泄露&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class JSONOut
{
	/**
	*按照JSON模板输出JSON数据
	*@param data 源数据
	*@param tplContent JSON模板内容
	*@param multi 是否为多条内容，默认单条
	*@return string
	*/
	public static function toJSON($data, $tplContent,$multi = false){
        if(empty($data)){
            return array();
        }
     
        $tplData = json_decode($tplContent,true);
        if(!$tplData){
            return false;
        }

        $array = array();
        if (!$multi) {
            // 一维数组
            $array = self::array_intersect_key_recursive($data,$tplData);
        } else {
            // 多维数组
            foreach($data as $key =&amp;gt; $value){
                $array[$key] = self::array_intersect_key_recursive($value,$tplData);
            }
        }

        return json_encode($array);
    }


    private static function array_intersect_key_recursive(array $array1, array $array2) {
        $array1 = array_intersect_key($array1, $array2);

        foreach ($array1 as $key =&amp;gt; &amp;amp;$value) {
            if (is_array($value) &amp;amp;&amp;amp; is_array($array2[$key])) {
                $value = $this-&amp;gt;array_intersect_key_recursive($value, $array2[$key]);
            }
        }
        return $array1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;测试代码&lt;/h2&gt;

&lt;p&gt;测试代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$tplContent = &amp;lt;&amp;lt;&amp;lt;EOT
{
  &quot;name&quot;: &quot;&quot;,
  &quot;avatar&quot;: &quot;&quot;
}
EOT;

//单条数据
$user  = array('id'=&amp;gt;1,'name' =&amp;gt; 'david','pass' =&amp;gt; '123456','phone'=&amp;gt;'13888888888','avatar' =&amp;gt; 'http://spetacular.github.io/images/favicon.ico');

echo JSONOut::toJSON($user,$tplContent,false);

echo &quot;\n&quot;;

//多条数据
$users  = [array('id'=&amp;gt;1,'name' =&amp;gt; 'david','pass' =&amp;gt; '123456','phone'=&amp;gt;'13888888888','avatar' =&amp;gt; 'http://spetacular.github.io/images/favicon.ico'),
array('id'=&amp;gt;2,'name' =&amp;gt; 'john','pass' =&amp;gt; '654321','phone'=&amp;gt;'13888888889','avatar' =&amp;gt; 'http://spetacular.github.io/images/favicon.png')];

echo JSONOut::toJSON($users,$tplContent,true);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试结果如下：&lt;/p&gt;

&lt;p&gt;单条数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;david&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;avatar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://spetacular.github.io/images/favicon.ico&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;多条数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
  {
    &quot;name&quot;: &quot;david&quot;,
    &quot;avatar&quot;: &quot;http://spetacular.github.io/images/favicon.ico&quot;
  },
  {
    &quot;name&quot;: &quot;john&quot;,
    &quot;avatar&quot;: &quot;http://spetacular.github.io/images/favicon.png&quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##未来扩展
注意到JSON模板仅有key，没有value，未来可以在value上扩展，比如默认值，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;gender&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果数据里没有gender的数据，则默认为0；&lt;/p&gt;

&lt;p&gt;或者在value上加过滤函数，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;int&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;表示age要转化为整型数字。&lt;/p&gt;
</description>
                <link>http://spetacular.github.io/2016/08/01/json-template-to-json.html</link>
                <guid>http://spetacular.github.io/2016/08/01/json-template-to-json</guid>
                <pubDate>Mon, 01 Aug 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Git使用Tips</title>
                <description>&lt;h1 id=&quot;git-clone-&quot;&gt;git clone 重命名文件夹&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/user/userApp.git name_you_want
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;git--push403&quot;&gt;git 多账户下 push出现403错误&lt;/h1&gt;
&lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin master&lt;/code&gt;时出现如下错误：
&amp;gt;remote: Permission to spetacular/asyntask.git denied to someone.
&amp;gt;fatal: unable to access ‘https://github.com/spetacular/asyntask.git/’: The requested URL returned error: 403&lt;/p&gt;

&lt;p&gt;这是由于.git/config的[remote “origin”]配置错误。可以更改此处代码。格式可以为以下两种情况：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
url=https://spetacular@github.com/spetacular/asyntask.git
url=ssh://git@github.com/spetacular/asyntask.git
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果不想更改全局配置，而只想临时使用：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
git push https://spetacular@github.com/spetacular/asyntask.git master
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;git-&quot;&gt;git 设置和取消网络代理&lt;/h1&gt;
&lt;p&gt;可设置为shadowsocks代理：
```
git config –global https.proxy http://127.0.0.1:1080&lt;/p&gt;

&lt;p&gt;git config –global https.proxy https://127.0.0.1:1080&lt;/p&gt;

&lt;p&gt;git config –global –unset http.proxy&lt;/p&gt;

&lt;p&gt;git config –global –unset https.proxy
```&lt;/p&gt;

&lt;h1 id=&quot;git-tag&quot;&gt;git 更新特定tag&lt;/h1&gt;
&lt;p&gt;已经打过tag，但又发现需要微调，再次&lt;code class=&quot;highlighter-rouge&quot;&gt;git tag  1.0.0&lt;/code&gt;时，会发生如下错误
&amp;gt;fatal: tag ‘1.0.0’ already exists&lt;/p&gt;

&lt;p&gt;1.删除本地tag:
&lt;code class=&quot;highlighter-rouge&quot;&gt;
 git tag -d 1.0.0
&lt;/code&gt;
2.重新打tag：
 &lt;code class=&quot;highlighter-rouge&quot;&gt;
 git tag  1.0.0
&lt;/code&gt;
3.push到服务器
 &lt;code class=&quot;highlighter-rouge&quot;&gt;
 git push --force origin refs/tags/1.0.0:refs/tags/1.0.0
&lt;/code&gt;&lt;/p&gt;

</description>
                <link>http://spetacular.github.io/2016/07/31/git-sample.html</link>
                <guid>http://spetacular.github.io/2016/07/31/git-sample</guid>
                <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Leetcode 344. Reverse String - 反转字符串</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;题目名称&lt;/h2&gt;

&lt;p&gt;Reverse String （反转字符串）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;题目地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-string/&quot;&gt;https://leetcode.com/problems/reverse-string/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;英文：Write a function that takes a string as input and returns the string reversed.&lt;/p&gt;

&lt;p&gt;Example:
Given s = “hello”, return “olleh”.&lt;/p&gt;

&lt;p&gt;中文：反转一个字符串。例如”hello”，转化为”olleh”。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解法&lt;/h2&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    func reverseString(s: String) -&amp;gt; String {
        var len = s.characters.count
        var sArr  = [Character](count:len, repeatedValue:&quot; &quot;)
        for i in s.characters{
            sArr[--len] = i
        }
        
        return String(sArr)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;算法复杂度为O(N)。&lt;/p&gt;

&lt;p&gt;还有一种时间复杂度为O(N/2)的解法，即交换与中心对称位置的字符，这样可以只循环N/2次。&lt;/p&gt;

</description>
                <link>http://spetacular.github.io/2016/07/25/reverse-string.html</link>
                <guid>http://spetacular.github.io/2016/07/25/reverse-string</guid>
                <pubDate>Mon, 25 Jul 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Leetcode 110. Balanced Binary Tree - 判断是否为平衡二叉树（递归解法）</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;题目名称&lt;/h2&gt;

&lt;p&gt;Balanced Binary Tree （判断是否为平衡二叉树）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;题目地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/balanced-binary-tree/&quot;&gt;https://leetcode.com/problems/balanced-binary-tree/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;英文：Given a binary tree, determine if it is height-balanced.&lt;/p&gt;

&lt;p&gt;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.&lt;/p&gt;

&lt;p&gt;中文：给一个二叉树，判断是否为平衡二叉树。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解法&lt;/h2&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    
    func getHeight(root: TreeNode?) -&amp;gt; Int{
        if root == nil {
            return 0
        }
        var leftCount = 0;
        var rightCount = 0;
        if root!.left != nil{
            leftCount = getHeight(root!.left) + 1
        }
        
        if root!.right != nil{
            rightCount = getHeight(root!.right) + 1
        }
        
        return leftCount &amp;gt; rightCount ? leftCount : rightCount
        
    }
    
    
    func isBalanced(root: TreeNode?) -&amp;gt; Bool {
        if root == nil {
            return true
        }
        var leftCount = root!.left == nil ? 0:getHeight(root!.left)+1
        var rightCount = root!.right == nil ? 0:getHeight(root!.right)+1
        if abs(leftCount-rightCount) &amp;gt; 1{
            return false
        }else if !isBalanced(root!.left) || !isBalanced(root!.right){
            return false
        }else{
            return true
        }
        
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试用例示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/balanced_tree_test_case.jpg&quot; alt=&quot;平衡二叉树测试用例&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class TreeNode {
     public var val: Int
     public var left: TreeNode?
     public var right: TreeNode?
     public init(_ val: Int) {
         self.val = val
         self.left = nil
         self.right = nil
     }
}

//[1,null,2,null,3]
var r1 = TreeNode(1)
var r2 = TreeNode(2)
var r3 = TreeNode(3)
r1.right = r2
r2.right = r3
var s = Solution()
s.isBalanced(r1)//false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
                <link>http://spetacular.github.io/2016/07/25/balanced-tree.html</link>
                <guid>http://spetacular.github.io/2016/07/25/balanced-tree</guid>
                <pubDate>Mon, 25 Jul 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Leetcode 172. Factorial Trailing Zeroes - 阶乘后缀0的数目（O(N)与O(logN)解法）</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;题目名称&lt;/h2&gt;

&lt;p&gt;Factorial Trailing Zeroes （阶乘后缀0的数目）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;题目地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/factorial-trailing-zeroes/&quot;&gt;https://leetcode.com/problems/factorial-trailing-zeroes/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;英文：Given an integer n, return the number of trailing zeroes in n!. &lt;br /&gt;
Note: Your solution should be in logarithmic time complexity.&lt;/p&gt;

&lt;p&gt;中文：给一个整型数字n，返回n!后缀0的数目。需要对数级别的时间复杂度。&lt;/p&gt;

&lt;p&gt;例如：10! = 3628800，后缀有两个0，返回2。&lt;/p&gt;

&lt;h2 id=&quot;on&quot;&gt;解法1 O(N)&lt;/h2&gt;
&lt;p&gt;首先是不太可能直接计算n!，然后看后缀0的数目，因为n!太大了！&lt;br /&gt;
我们先用笨办法，先算出前25个数字的结果，看能否找到规律。&lt;br /&gt;
&lt;img src=&quot;http://spetacular.github.io/images/2016/zeros.png&quot; alt=&quot;n!与后缀0数目的关系&quot; /&gt;
可以看到，后缀0数目发生变化的点，都是5的整数倍，如5，10，15，20，25…
这容易理解，产生后缀0，只能是与10相乘，而10 ＝ 2 * 5，2广泛存在于偶数中，所以不用关注。只需要知道5的倍数的整数即可。&lt;/p&gt;

&lt;p&gt;给定整数n，要找到以下数字，其中x*5^y &amp;lt;= n：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5,10,15,...,x*5^y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后看每个数字能分解出y个5:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1,1,1,...,y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后的结果就是如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sum(1,1,1,...,y)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    func trailingZeroes(n: Int) -&amp;gt; Int {
        if n &amp;lt; 5{
            return 0
        }
        var i = 5
        var ret = 0
        while i &amp;lt;= n{
            ret += num_of_five(i)
            i += 5
        }
        return ret
    }
    
    func num_of_five(n: Int) -&amp;gt;(Int) {
        var i = n
        var ret = 0
      
        while i &amp;gt; 0{
            if i % 5 != 0 {
                break
            }
            i = i / 5
            if i &amp;gt;= 1{
                ret++
            }
        }
        
        return ret
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个算法需要循环(n/5)次，时间复杂度为O(N)，尽管“政治正确”，但不是最好的解法。&lt;/p&gt;

&lt;h2 id=&quot;ologn&quot;&gt;解法2 O(logN)&lt;/h2&gt;

&lt;p&gt;将解法1的过程再回顾下，计算5出现的次数，可以分解看：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;出现5，计数加1；
出现5*5，计数加2；
出现5*5*5，计数加3；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;换个角度看，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;除以5，计数加1；
除以5，计数加1；除以5*5，计数加1；
除以5，计数加1；除以5*5，计数加1；除以5*5*5，计数加1；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么最后结果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;floor(n/5) + floor(n/25) + floor(n/125) + ....
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution1 {
    func trailingZeroes(n: Int) -&amp;gt; Int {
        var i = 5
        var ret = 0
        while i &amp;lt;= n{
            ret += n / i
            i *= 5
        }
        return ret
    }
}	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;算法复杂度为O(logN)。&lt;/p&gt;

</description>
                <link>http://spetacular.github.io/2016/07/24/factorial-trailing-zeroes.html</link>
                <guid>http://spetacular.github.io/2016/07/24/factorial-trailing-zeroes</guid>
                <pubDate>Sun, 24 Jul 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Leetcode 21. Merge Two Sorted Lists - 合并有序链表（递归与非递归解法）</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;题目名称&lt;/h2&gt;

&lt;p&gt;Merge Two Sorted Lists （合并有序链表）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;题目地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-sorted-lists/&quot;&gt;https://leetcode.com/problems/merge-two-sorted-lists/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;英文：Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;

&lt;p&gt;中文：有两个有序链表，将之合并为一个有序链表。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解法1 递归&lt;/h2&gt;
&lt;p&gt;合并过程是这样的：先比较两个链表的头节点，节点值小的先摘到新链表中；然后再处理剩下的链表，直到两个链表都为空。递归解法比较容易实现。&lt;/p&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    func mergeTwoLists(l1: ListNode?, _ l2: ListNode?) -&amp;gt; ListNode? {
        if l1 == nil{
            return l2
        }
        if l2 == nil{
            return l1
        }
        var ret: ListNode?
        if l1!.val &amp;gt; l2!.val{
            ret = l2
            ret!.next = mergeTwoLists(l1,l2!.next)
        } else {
            ret = l1
            ret!.next = mergeTwoLists(l1!.next,l2)
        }
        return ret
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;解法2 非递归&lt;/h2&gt;
&lt;p&gt;也可以用while循环来做。就是用一个tail指针遍历两个链表，每次走到值较小的节点上，直到其中一个链表走到头。最后拼上另一个链表即可。&lt;/p&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    func mergeTwoLists(l1: ListNode?, _ l2: ListNode?) -&amp;gt; ListNode? {
        if l1 == nil{
            return l2
        }
        if l2 == nil{
            return l1
        }
        var head: ListNode?
        var tail: ListNode?
        var ll1 = l1
        var ll2 = l2
        if l1!.val &amp;gt; l2!.val{
            head = l2
            ll2 = l2!.next
        }else{
            head = l1
            ll1 = l1!.next
        }
        tail = head
        head?.next = tail
        while ll1 != nil &amp;amp;&amp;amp; ll2 != nil{
            if ll1!.val &amp;gt; ll2!.val{
                tail?.next = ll2
                tail = ll2
                ll2 = ll2?.next
            }else{
                tail?.next = ll1
                tail = ll1
                ll1 = ll1?.next
            }
        }
        if ll1 == nil{
            tail?.next = ll2
        }
        if ll2 == nil{
            tail?.next = ll1
        }
        return head
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假设l1长度为M，l2长度为N，则算法复杂度为O(M+N)。&lt;/p&gt;

</description>
                <link>http://spetacular.github.io/2016/07/23/merge-two-sorted-lists.html</link>
                <guid>http://spetacular.github.io/2016/07/23/merge-two-sorted-lists</guid>
                <pubDate>Sat, 23 Jul 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Leetcode 258. Add Digits - 非负整数各位相加（另外一个解法）</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;题目名称&lt;/h2&gt;

&lt;p&gt;Add Digits （非负整数各位相加）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;题目地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-digits&quot;&gt;https://leetcode.com/problems/add-digits&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;英文：Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.&lt;/p&gt;

&lt;p&gt;中文：有一个非负整数num，重复这样的操作：对该数字的各位数字求和，对这个和的各位数字再求和……直到最后得到一个仅1位的数字（即小于10的数字）。&lt;/p&gt;

&lt;p&gt;例如：num=38，3+8=11,1+1=2。因为2小于10，因此返回2。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解法1&lt;/h2&gt;
&lt;p&gt;该算法有一个O(1)复杂度的&lt;a href=&quot;http://my.oschina.net/Tsybius2014/blog/497645&quot; title=&quot;LeetCode：Add Digits - 非负整数各位相加&quot;&gt;《解法》&lt;/a&gt;。其中的公式为 (num - 1) % 9 + 1。这里引用一下这个公式的推导过程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;假设输入的数字是一个5位数字num，则num的各位分别为a、b、c、d、e。有如下关系：num = a * 10000 + b * 1000 + c * 100 + d * 10 + e  
即：num = (a + b + c + d + e) + (a * 9999 + b * 999 + c * 99 + d * 9)  
因为 a * 9999 + b * 999 + c * 99 + d * 9 一定可以被9整除，因此num模除9的结果与 a + b + c + d + e 模除9的结果是一样的。  
对数字 a + b + c + d + e 反复执行同类操作，最后的结果就是一个 1-9 的数字加上一串数字，最左边的数字是 1-9 之间的，右侧的数字永远都是可以被9整除的。  
这道题最后的目标，就是不断将各位相加，相加到最后，当结果小于10时返回。因为最后结果在1-9之间，得到9之后将不会再对各位进行相加，因此不会出现结果为0的情况。因为 (x + y) % z = (x % z + y % z) % z，又因为 x % z % z = x % z，因此结果为 (num - 1) % 9 + 1，只模除9一次，并将模除后的结果加一返回。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个公式是正确的，但这个推导过程有待商榷。为什么要num要先减1，最后再加上1？&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;解法2&lt;/h2&gt;
&lt;p&gt;其实还有一个更容易的理解的解法。推导过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;假设输入的数字是一个5位数字num，则num的各位分别为a、b、c、d、e。有如下关系：num = a * 10000 + b * 1000 + c * 100 + d * 10 + e  
即：num = (a + b + c + d + e) + (a * 9999 + b * 999 + c * 99 + d * 9)  
因为 a * 9999 + b * 999 + c * 99 + d * 9 一定可以被9整除，因此num模除9的结果与 a + b + c + d + e 模除9的结果是一样的。
所以最后的结果是：num % 9.
但是这个结果需要修正一下：如果num能被9整除，则结果为0，这时应该修正为9.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后整个算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    func addDigits(num: Int) -&amp;gt; Int {
        if num == 0 {
            return 0
        }
        var mod = num % 9
        if mod == 0 {
            return 9
        }else{
            return mod
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;算法复杂度也为O(1)。&lt;/p&gt;

</description>
                <link>http://spetacular.github.io/2016/07/22/leetcode-258-add-digits.html</link>
                <guid>http://spetacular.github.io/2016/07/22/leetcode-258-add-digits</guid>
                <pubDate>Fri, 22 Jul 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>PHP性能监控问题记录之二－session与gc过程</title>
                <description>&lt;h2 id=&quot;sessionstartgc&quot;&gt;session_start与gc垃圾回收过程&lt;/h2&gt;
&lt;p&gt;在调性能时，偶然发现有个session函数（ThinkPHP/Common/functions.php）耗时很大。查了一下，ThinkPHP框架默认开启了session，就是每次请求都会调用session_start。 这里面存在问题。&lt;br /&gt;
因为在PHP中, 如果使用file_handler作为Session的save handler, 那么就有概率在每次session_start的时候运行Session的Gc过程。详见&lt;a href=&quot;http://www.laruence.com/2011/03/29/1949.html&quot;&gt;鸟哥的分析&lt;/a&gt;。&lt;br /&gt;
这样就造成每隔一段时间，session函数这里触发了Gc过程，就变慢了。&lt;/p&gt;

&lt;p&gt;解决方法是将session_start默认关闭，需要时再打开。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'SESSION_AUTO_START'=&amp;gt;false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
                <link>http://spetacular.github.io/2016/06/16/session-and-gc.html</link>
                <guid>http://spetacular.github.io/2016/06/16/session-and-gc</guid>
                <pubDate>Thu, 16 Jun 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>PHP性能监控问题记录之一－安装配置php-apm</title>
                <description>&lt;h2 id=&quot;php-apm&quot;&gt;php-apm是什么&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/patrickallaert/php-apm&quot;&gt;php-apm&lt;/a&gt;是一个PHP的性能检测工具，它能方便地捕捉到错误信息，并提供错误追踪回溯，获取请求的统计内存、CPU、响应时间的统计信息，并提供&lt;a href=&quot;https://github.com/patrickallaert/php-apm-web&quot;&gt;可视化的展示&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;apm&quot;&gt;安装apm&lt;/h2&gt;
&lt;p&gt;安装apm有两种方式：从PECL安装，或从源码编译。这里采用PECL安装。源码编译见&lt;a href=&quot;https://github.com/patrickallaert/php-apm#from-source&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo pecl install apm
WARNING: channel &quot;pecl.php.net&quot; has updated its protocols, use &quot;pecl channel-update pecl.php.net&quot; to update
downloading APM-2.0.5.tgz ...
Starting to download APM-2.0.5.tgz (31,484 bytes)
.........done: 31,484 bytes
14 source files, building
running: phpize
Configuring for:
PHP Api Version:         20131106
Zend Module Api No:      20131226
Zend Extension Api No:   220131226
Enable Sqlite3 support [yes] : no
Enable MariaDB/MySQL support [yes] : yes
Enable Socket support [yes] : yes
Enable Statsd support [yes] : yes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;出现了如下错误：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;configure: error: Cannot find MySQL header files
ERROR: `/tmp/pear/temp/APM/configure --with-php-config=/usr/bin/php-config --with-sqlite3=no --with-mysql --enable-socket=yes --enable-statsd=yes' failed
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要安装下mysql dev&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install mysql-client libmysqlclient-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;apm-1&quot;&gt;配置apm&lt;/h2&gt;
&lt;p&gt;在php.ini上配置apm。apm.so依赖于json.so，如果之前没有加载，则应先加载。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension=json.so
extension=apm.so
;;;;;;;;;;;;;;;;;;;
; Module Settings ;
;;;;;;;;;;;;;;;;;;;

;apm
apm.mysql_enabled=1
; Error reporting level specific to the MariaDB/MySQL driver, same level as for PHP's *error_reporting*
apm.mysql_error_reporting=E_ALL|E_STRICT
apm.mysql_stats_enabled=1
apm.mysql_host=localhost
apm.mysql_port=3306
apm.mysql_user=apm
apm.mysql_pass=apm
apm.mysql_db=apm
apm.socket_enabled=0
apm.socket_stats_enabled=0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后重启php，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service php5-fpm restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;apm-web&quot;&gt;部署apm-web&lt;/h2&gt;
&lt;p&gt;apm提供了一个web端查看的项目，地址为：&lt;a href=&quot;https://github.com/patrickallaert/php-apm-web&quot;&gt;https://github.com/patrickallaert/php-apm-web&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;将&lt;a href=&quot;https://github.com/patrickallaert/php-apm-web/archive/master.zip&quot;&gt;https://github.com/patrickallaert/php-apm-web/archive/master.zip&lt;/a&gt;解压后上传到网站根目录，或者如果使用git，可以clone到网站根目录下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/patrickallaert/php-apm-web.git apm-web
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后编辑config/db.php文件。如果选用mysql，可以如下配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return new PDO(&quot;mysql:host=localhost;dbname=apm&quot;, &quot;apm&quot;, &quot;apm&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后的效果如下：&lt;/p&gt;

&lt;p&gt;返回Error的请求列表
&lt;img src=&quot;http://spetacular.github.io/images/2016/web_apm_faulty.png&quot; alt=&quot;返回Error的请求列表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击每一列，都会出现请求的URL、时间、内存、CPU使用情况，以及错误信息。
&lt;img src=&quot;http://spetacular.github.io/images/2016/web_apm_e_error.png&quot; alt=&quot;错误信息&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击错误信息，会出现该错误的Stacktrace。
&lt;img src=&quot;http://spetacular.github.io/images/2016/web_apm_stacktrace.png&quot; alt=&quot;错误追踪回溯&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有详细的访问统计日志。
&lt;img src=&quot;http://spetacular.github.io/images/2016/web_apm_stats.png&quot; alt=&quot;访问日志&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;常见问题&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;问题1 部署后无数据，且扩展未加载。&lt;/h3&gt;

&lt;p&gt;检测php.ini文件，看是否有apm扩展。如果出现类似如下的信息，则说明扩展已加载。
&lt;img src=&quot;http://spetacular.github.io/images/2016/php_ini_apm.png&quot; alt=&quot;php.ini文件&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;问题2 部署后无数据，扩展已加载。&lt;/h3&gt;

&lt;p&gt;mysql_stats_enabled默认值为0，这时是不收集的。可以设置apm.mysql_stats_enabled=1。&lt;/p&gt;

</description>
                <link>http://spetacular.github.io/2016/06/15/problem-tips.html</link>
                <guid>http://spetacular.github.io/2016/06/15/problem-tips</guid>
                <pubDate>Wed, 15 Jun 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>社交网站:热门内容排名算法浅议</title>
                <description>&lt;p&gt;热门内容对任何网站都很重要，对社交网站更为重要。如何让用户第一眼就看到感兴趣的内容而留下来，正是各种排名算法的任务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/top-10.png&quot; alt=&quot;热门 top 10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设计一个好的排名算法，需要考虑的因素很多，其中最重要的是以下两点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;社区属性及内容属性&lt;/li&gt;
  &lt;li&gt;网站本身内容的量级与更新频率&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者决定采用何种排名算法，后者确定排名的上升与下降速度。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;影响因素&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;社区属性及内容属性&lt;/h2&gt;
&lt;p&gt;社交网站产生许多用户上传的内容，对这些内容进行排名时，需要考虑内容本身的信息。&lt;/p&gt;

&lt;p&gt;从类型上，UGC内容主要是图片、文章、音频还是视频？一般来说，图片扫一眼，文章读一遍，音频听一次，视频看一遍,占用用户的时间依次增加,留住用户的成本也随之增加。&lt;/p&gt;

&lt;p&gt;从特征上，单图或多图？段子还是长文？一首歌还是一集Podcast？短视频还是长视频？越复杂的形式，用户付出的时间成本越大。&lt;/p&gt;

&lt;p&gt;用户付出了时间，那么会要求回报。网站回报用户的东西，无外乎兴趣和价值。而兴趣和价值，是两条不同方向的岔路，通向不同的排名算法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/cross-road.jpg&quot; alt=&quot;排名算法&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;网站本身内容的量级与更新频率&lt;/h2&gt;

&lt;p&gt;内容的量级，像大象与蚂蚁，体量越大，系统越复杂。从海量内容中挑选出热门内容，需要更多的参数和指标。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/ele-ant.jpg&quot; alt=&quot;内容的量级对排名算法影响很大&quot; /&gt;&lt;/p&gt;

&lt;p&gt;更新频率，像流水线与手工作坊，频率越快，产出越多。新内容产生出来后，排名需要很快地上升，才能排到前列，引起注意；旧内容存在一段时间后，排名需要很快地下降，才能让位给新内容。&lt;/p&gt;

&lt;p&gt;所以，需要根据网站本身的内容，确定排名算法需要考虑的参数，以及确定参数的取值。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;兴趣与价值&lt;/h2&gt;
&lt;p&gt;用户留下来，无外乎几种情况：这个东西很有趣（有趣型），或这个东西对我有用（有用型），或者兼而有之。&lt;/p&gt;

&lt;p&gt;有趣的东西，用户第一眼看到就喜欢，但内容本身没有收藏价值。用户的态度是：见之我喜，不见也有其它东西让我喜。例如各种段子、笑话、gif图等。&lt;/p&gt;

&lt;p&gt;有用的内容，用户看后念念不忘，收藏以备以后查看、回味与参考。例如旅游攻略、喜欢的文章、好听的歌曲等。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;排名如何上升&lt;/h1&gt;
&lt;p&gt;新内容一产生出来就具有上升趋势。&lt;/p&gt;

&lt;p&gt;用户浏览、like（点赞、顶，喜欢）、评论、高评分（星级），编辑推荐等，都会使排名上升。&lt;/p&gt;

&lt;p&gt;有趣型的内容，排名迅速上升，如病毒般地传播开来。
&lt;img src=&quot;http://spetacular.github.io/images/2016/up_1.png&quot; alt=&quot;上升趋势，增速逐渐变小&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有用型的内容，排名逐渐上升，越到后来越多人知道它的价值。
&lt;img src=&quot;http://spetacular.github.io/images/2016/up_2.png&quot; alt=&quot;上升趋势，增速逐渐变大&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;排名如何下降&lt;/h1&gt;

&lt;p&gt;旧内容渐渐呈现下降趋势。&lt;/p&gt;

&lt;p&gt;少有访问、dislike（讨厌、踩，反对）、低评分（星级）、编辑降权，都会使排名下降。&lt;/p&gt;

&lt;p&gt;有趣型的内容，排名维持了一段新鲜期后，大部分用户就失去兴趣了。
&lt;img src=&quot;http://spetacular.github.io/images/2016/down_1.png&quot; alt=&quot;下降趋势，增速逐渐变大&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有用型的内容，排名虽然下降了，但其价值还在，还会不断有人关注。
&lt;img src=&quot;http://spetacular.github.io/images/2016/down_2.png&quot; alt=&quot;下降趋势，增速逐渐变小&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;没有银弹&lt;/h1&gt;
&lt;p&gt;知名博主阮一峰发表了6篇&lt;a href=&quot;http://www.ruanyifeng.com/blog/it/algorithm/&quot; title=&quot;基于用户投票的排名算法&quot;&gt;基于用户投票的排名算法&lt;/a&gt;的系列文章。这6篇文章剖析了几个网站的排名算法。&lt;/p&gt;

&lt;p&gt;如Delicious采用”过去60分钟内被收藏的次数”进行排名。每过60分钟，就统计一次。它的上升和下降趋势就是阶梯函数式的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/step_function.gif&quot; alt=&quot;阶梯函数&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hacker News采用票数计算排名，并考虑时间因素，分数随着时间逐渐减小。看下降曲线，Hacker News属于有趣型的网站（用户当然可以获得价值，这里指排名算法的类型）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/ruanyifeng_hacknews.png&quot; alt=&quot;Hacker News下降趋势&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Stack Overflow属于有用型的网站。一个问题提出后，需要网友的回答、对答案投赞成或反对票、评论。这些内容的完善都需要时间。所以，随着时间的推移，一些问题和答案的价值开始慢慢显露，当你搜索时，Statck Overflow就会给你展示最有用的内容。
&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/40dfde6fjw1f1m9pxx416j20go0lwgov.jpg&quot; alt=&quot;Stack Overflow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;redit也属于有趣型的网站。它的时间因素占主导，就是说任何人发的新内容都比较容易靠前；排名算法中利用了赞成票与反对票的差额，说明有争议（很多人赞成，同时很多人反对）的内容，排名靠后；很多人赞成，很少人反对的内容，排名靠前。阮一峰得出结论：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这决定了Reddit是一个符合大众口味的社区，不是一个很激进、可以展示少数派想法的地方。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这也说明了，没有银弹，要建设什么样的社区，就要采用能体现社区特征的排名算法。&lt;/p&gt;

</description>
                <link>http://spetacular.github.io/2016/02/15/sns-hot-feed-ranking-algorithm.html</link>
                <guid>http://spetacular.github.io/2016/02/15/sns-hot-feed-ranking-algorithm</guid>
                <pubDate>Mon, 15 Feb 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Redis技巧:phpredis扩展安装与升级</title>
                <description>&lt;p&gt;为了使用zscan来处理有序集合（Sorted Set）按模式获取数据，需要将phpredis扩展从2.2.4升级到2.2.5以上（最新版本为2.2.7）。&lt;/p&gt;

&lt;p&gt;安装和升级方法：&lt;/p&gt;

&lt;p&gt;1.下载安装扩展&lt;/p&gt;

&lt;p&gt;网址：https://pecl.php.net/package/redis&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  wget https://pecl.php.net/get/redis-2.2.7.tgz
  tar zxvf redis-2.2.7.tgz
  cd redis-2.2.7
  phpize
  ./configure
  make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.检查：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  php -i | grep Redis
  Redis Support =&amp;gt; enabled
  Redis Version =&amp;gt; 2.2.7
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装或升级成功。&lt;/p&gt;

&lt;p&gt;3.重启php5-fpm&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  service php5-fpm restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
                <link>http://spetacular.github.io/2016/01/29/install-and-upgrade-phpredis-extions.html</link>
                <guid>http://spetacular.github.io/2016/01/29/install-and-upgrade-phpredis-extions</guid>
                <pubDate>Fri, 29 Jan 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Redis技巧:Sorted Set使用</title>
                <description>&lt;p&gt;有序集合(Sorted Set)是Redis一个很重要的数据结构，它用来保存需要排序的数据。例如排行榜，一个班的语文成绩，一个公司的员工工资，一个论坛的帖子等。有序集合中，每个元素都带有score（权重），以此来对元素进行排序。它有三个元素：key、member和score。以语文成绩为例，key是考试名称（期中考试、期末考试等），member是学生名字，score是成绩。&lt;/p&gt;

&lt;p&gt;有序集合有两大基本用途：排序和聚合，以下用几个例子分别说明。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;排序&lt;/h1&gt;
&lt;p&gt;假设老师需要处理期中考试的语文成绩，他做的第一件事是将学生成绩录入系统。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Li Lei成绩70分
  127.0.0.1:6379&amp;gt; ZADD mid_test 70 &quot;Li Lei&quot;
  (integer) 1

  Han Meimei成绩70分
  127.0.0.1:6379&amp;gt; ZADD mid_test 70 &quot;Han Meimei&quot;
  (integer) 1

  tom成绩99.5分
  127.0.0.1:6379&amp;gt; ZADD mid_test 99.5 &quot;Tom&quot;
  (integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###排行榜
有序集合天然就是做排行榜的利器。只需将带score的member塞到有序集合里，就可以正序或倒序取出数据。这要用到ZREVRANGE（倒序）和ZRANGE（正序）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  分数排行榜
  127.0.0.1:6379&amp;gt; ZREVRANGE mid_test 0 -1 WITHSCORES
  1) &quot;Tom&quot;
  2) &quot;99.5&quot;
  3) &quot;Li Lei&quot;
  4) &quot;70&quot;
  5) &quot;Han Meimei&quot;
  6) &quot;70&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###分段统计
有序集合还支持按score区间来查询：ZREVRANGEBYSCORE为倒序查询，ZRANGEBYSCORE为正序。例如要知道90分以上的学霸：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; ZREVRANGEBYSCORE mid_test 100 90 WITHSCORES
  1) &quot;Tom&quot;
  2) &quot;99.5&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;#聚合 
有序集合，其本质是集合，当然会有交集（&lt;a href=&quot;http://redisdoc.com/sorted_set/zinterstore.html&quot; title=&quot;ZINTERSTORE&quot;&gt;ZINTERSTORE&lt;/a&gt;）和并集（&lt;a href=&quot;http://redisdoc.com/sorted_set/zunionstore.html&quot; title=&quot;ZUNIONSTORE&quot;&gt;ZUNIONSTORE&lt;/a&gt;）运算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2015-11-01/inter-union.jpg&quot; alt=&quot;交集和并集&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###交集
&lt;a href=&quot;http://redisdoc.com/sorted_set/zinterstore.html&quot; title=&quot;ZINTERSTORE&quot;&gt;ZINTERSTORE&lt;/a&gt;取所有集合的并集。以两个集合A和B为例，要取交集C，是这样的逻辑：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A和B中共有的member，会加入到C中，其score等于A、B中score之和。&lt;/li&gt;
  &lt;li&gt;不同时在A和B的member，不会加到C中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;某班又进行了期末考试，同时来了个新同学Jerry。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; ZADD fin_test 88 &quot;Li Lei&quot;
  (integer) 1
  127.0.0.1:6379&amp;gt; ZADD fin_test 75 &quot;Han Meimei&quot;
  (integer) 1
  127.0.0.1:6379&amp;gt; ZADD fin_test 99.5 &quot;Tom&quot;
  (integer) 1
  127.0.0.1:6379&amp;gt; ZADD fin_test 100 &quot;Jerry&quot;
  (integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;老师要按期中考试和期末考试的总成绩来排座位，就对mid_test和fin_test做了个交集。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; ZINTERSTORE sum_point 2 mid_test fin_test
  (integer) 3
  127.0.0.1:6379&amp;gt; ZREVRANGE sum_point 0 -1 WITHSCORES
  1) &quot;Tom&quot;
  2) &quot;199&quot;
  3) &quot;Li Lei&quot;
  4) &quot;158&quot;
  5) &quot;Han Meimei&quot;
  6) &quot;145&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果显示了学生的总成绩。
但结果中没有新来的Jerry同学（尽管TA考了100分）。这是坑一。&lt;/p&gt;

&lt;p&gt;###并集
&lt;a href=&quot;http://redisdoc.com/sorted_set/zunionstore.html&quot; title=&quot;ZUNIONSTORE&quot;&gt;ZUNIONSTORE&lt;/a&gt;计算所有集合的并集。以两个集合A和B为例，要取并集C，是这样的逻辑：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A的所有member会加到C中，其score与A中相等&lt;/li&gt;
  &lt;li&gt;B的所有member会加到C中，其score与B中相等&lt;/li&gt;
  &lt;li&gt;A和B中共有的member，其score等于A、B中score之和。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假设某公司要核算工资总支出，先由各部门独自核算，再由财务统一处理。&lt;/p&gt;

&lt;p&gt;程序员工资&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; zadd programmer 2000 peter
  (integer) 1
  127.0.0.1:6379&amp;gt; zadd programmer 3500 jack
  (integer) 1
  127.0.0.1:6379&amp;gt; zadd programmer 5000 tom
  (integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;经理工资&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; zadd manager 2000 herry
  (integer) 1
  127.0.0.1:6379&amp;gt; zadd manager 3500 mary
  (integer) 1
  127.0.0.1:6379&amp;gt; zadd manager 4000 tom
  (integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;财务统一处理。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; zunionstore salary 2 programmer manager
  (integer) 5
  127.0.0.1:6379&amp;gt; zrange salary 0 -1 withscores
   1) &quot;herry&quot;
   2) &quot;2000&quot;
   3) &quot;peter&quot;
   4) &quot;2000&quot;
   5) &quot;jack&quot;
   6) &quot;3500&quot;
   7) &quot;mary&quot;
   8) &quot;3500&quot;
   9) &quot;tom&quot;
  10) &quot;9000&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果显示了总工资支出情况。&lt;/p&gt;

&lt;p&gt;但结果中程序员tom和经理tom是两个人，但工资算在了一起。这是坑二。&lt;/p&gt;

&lt;p&gt;#避免踩坑&lt;/p&gt;

&lt;p&gt;还记得上面说的坑一和坑二吗？&lt;/p&gt;

&lt;p&gt;坑一：&lt;/p&gt;

&lt;p&gt;当进行ZINTERSTORE操作时，如果进行聚合操作的源集合中元素不同，则聚合后的结果集仅为并集。如果发现聚合后少了一些元素，请查看源集合元素是否相同。&lt;/p&gt;

&lt;p&gt;坑二：&lt;/p&gt;

&lt;p&gt;当进行ZUNIONSTORE操作时，如果进行聚合操作的源集合中有相同元素，则聚合后的结果集中，相同元素的score等于源集合元素的score之和。如果发现聚合后某些元素的score异常，请查看源集合是否有相同元素。&lt;/p&gt;

&lt;p&gt;我踩过的坑：&lt;/p&gt;

&lt;p&gt;做用户的feed（timeline）时，需要将我关注的人和我自己发表的信息聚合起来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2015-11-01/feed-timeline.jpg&quot; alt=&quot;timeline &amp;amp; feed&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应该用ZUNIONSTORE将所有信息聚合到一起。&lt;/p&gt;

&lt;p&gt;后来有用户反馈说timeline排序错误，自己发表发布的信息永远在最上面。后来查明原因，由于早期的bug，自己竟然可以关注自己，导致关注人和自己重复聚合。踩到了坑二。&lt;/p&gt;

&lt;p&gt;#为什么踩坑
以坑二为例，为什么有相同元素时，score就会变成原来元素的和？&lt;/p&gt;

&lt;p&gt;因为ZINTERSTORE和ZUNIONSTORE有个参数为AGGREGATE，表示结果集的聚合方式，可取SUM、MIN、MAX其中之一。默认值为SUM。&lt;/p&gt;

&lt;p&gt;所以不指定聚合方式时，缺省值为SUM，即求和。&lt;/p&gt;

&lt;blockquote&gt;
  默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。
&lt;/blockquote&gt;

&lt;p&gt;文档如上。&lt;/p&gt;

&lt;p&gt;#有序集合之总结&lt;/p&gt;

&lt;p&gt;使用场景：排行榜，有序列表，聚合；&lt;/p&gt;

&lt;p&gt;算法复杂度：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;增删：O(M*log(N))， N 为有序集的基数， M 为被成功操作（新增、移除）的成员的数量。&lt;/li&gt;
  &lt;li&gt;查询：O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。&lt;/li&gt;
  &lt;li&gt;聚合：O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。&lt;/li&gt;
  &lt;li&gt;总数：O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意事项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ZINTERSTORE操作时,如果发现聚合后少了一些元素，请查看源集合元素是否相同。&lt;/li&gt;
  &lt;li&gt;ZUNIONSTORE操作时,如果发现聚合后某些元素的score异常，请查看源集合是否有相同元素。&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://spetacular.github.io/2015/11/01/redis-zunionstore-tip.html</link>
                <guid>http://spetacular.github.io/2015/11/01/redis-zunionstore-tip</guid>
                <pubDate>Sun, 01 Nov 2015 00:00:00 +0800</pubDate>
        </item>


</channel>
</rss>
