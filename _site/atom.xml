<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>David's World</title>
 <link href="http://spetacular.github.io/atom.xml" rel="self"/>
 <link href="http://spetacular.github.io"/>
 <updated>2017-03-22T17:28:55+08:00</updated>
 <id>http://spetacular.github.io</id>
 <author>
   <name>David</name>
   <email>blah@email.test</email>
 </author>

 
 <entry>
   <title>Docker:网络配置</title>
   <link href="http://spetacular.github.io/2017/03/20/docker-network-settings.html"/>
   <updated>2017-03-20T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/03/20/docker-network-settings</id>
   <content type="html">&lt;p&gt;Docker运行容器时，一个常见的问题是：localhost(127.0.0.1)指向哪里？这涉及到Docker的网络配置问题。&lt;/p&gt;

&lt;!-- Docker 一个常用用法是开放特定端口来对外提供服务，如 Mysql 占用3306端口，redis 占用 6379 端口。这样就牵扯到网络配置的问题（以 Mysql 为例）：    
1. localhost(127.0.0.1)指向哪里？     
2. [宿主机](/2017/03/10/docker-basic-concept.html#host)如何连接到Mysql服务所在的容器？   
3. 另一台运行在容器内的php服务如何连接到 Mysql 服务器所在的容器？ --&gt;

&lt;p&gt;Docker支持的网络模式如下：bridge（默认）、host、container、network-name、none。&lt;/p&gt;

&lt;h1 id=&quot;bridge&quot;&gt;桥接 bridge&lt;/h1&gt;
&lt;p&gt;Docker 默认的网络模式是 bridge 。在该模式下，docker 创建了一个 bridge，名称通常为 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt; 。 &lt;br /&gt;
可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;ifconfig&lt;/code&gt;来查看：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
docker0   Link encap:Ethernet  HWaddr **:**:**:**:**:**
          inet addr:192.168.0.1  Bcast:0.0.0.0  Mask:255.255.240.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:305002 errors:0 dropped:0 overruns:0 frame:0
          TX packets:407006 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:30331811 (30.3 MB)  TX bytes:752905683 (752.9 MB)
&lt;/code&gt;
宿主机和容器通过bridge进行通信，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/docker-networking-bridge-mode.jpeg&quot; alt=&quot;docker桥接bridge模式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;容器内的localhost指向容器内部。&lt;/p&gt;

&lt;h1 id=&quot;host&quot;&gt;本机 host&lt;/h1&gt;
&lt;p&gt;当使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--net=host&lt;/code&gt;启动容器时，网络配置为 host 模式。该模式下，容器和宿主机共享网络。形象地讲，容器和宿主机共享一个网卡，在容器内的网络访问如同直接在宿主机上操作一样。例如：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
docker run --rm -it --net=host ubuntu:trusty bash
&lt;/code&gt;
容器内的localhost指向宿主机。
&lt;img src=&quot;/images/2016/docker-networking-host-mode.jpeg&quot; alt=&quot;docker桥接host模式&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;container&quot;&gt;container&lt;/h1&gt;
&lt;p&gt;Docker可以指定一个容器复用另一个容器的网络设置。这种模式适用于由多个容器搭建整套系统的情况，例如搭建PHP开发环境时，希望Mysql、Redis都使用PHP容器的网络配置，即可以使用该模式。&lt;/p&gt;

&lt;h1 id=&quot;network-name&quot;&gt;network-name&lt;/h1&gt;
&lt;p&gt;Docker允许用户使用Docker network driver或[第三方network driver插件]（https://docs.docker.com/engine/extend/legacy_plugins/#network-plugins）创建自定义网络，然后多个容器都可以使用相同的网络。常见的第三方etwork driver插件有：&lt;a href=&quot;https://github.com/contiv/netplugin&quot;&gt;Contiv Networking&lt;/a&gt;、&lt;a href=&quot;https://github.com/openstack/kuryr&quot;&gt;Kuryr Network Plugin&lt;/a&gt;、&lt;a href=&quot;https://www.weave.works/docs/net/latest/introducing-weave/&quot;&gt;Weave Network Plugin&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;none&quot;&gt;none&lt;/h1&gt;
&lt;p&gt;顾名思义，该模式下没有网络连接。例如我的宿主机ip为192.168.0.59，在容器内访问宿主机就提示无网络。
&lt;code class=&quot;highlighter-rouge&quot;&gt;
docker run -it --net=none my_ubuntu bash
root@6533968160dd:/# ping 192.168.0.59
connect: Network is unreachable
&lt;/code&gt;&lt;/p&gt;

&lt;!-- # Docker为什么没有 nat 模式 --&gt;
</content>
 </entry>
 
 <entry>
   <title>Docker:基本概念</title>
   <link href="http://spetacular.github.io/2017/03/10/docker-basic-concept.html"/>
   <updated>2017-03-10T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/03/10/docker-basic-concept</id>
   <content type="html">&lt;h1 id=&quot;image&quot;&gt;&lt;a href=&quot;#image&quot;&gt;镜像&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Docker镜像Image是一个就像具有&lt;a href=&quot;https://zh.wikipedia.org/wiki/Time_Machine&quot;&gt;Time Machine&lt;/a&gt;功能的虚拟机，保存着特定时刻的一个快照。这个快照包含了已安装的程序、共享库、配置文件、环境变量、用户组等信息。构建Image时，以上内容不会改变。这意味着可以利用Image快速复制出多个相同的运行实体（容器）。&lt;/p&gt;

&lt;h1 id=&quot;container&quot;&gt;&lt;a href=&quot;#container&quot;&gt;容器&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Docker容器container是镜像Image的运行实体。一个镜像可以生成多个相同的容器，每个容器的代码、运行环境、系统工具、系统库都完全相同。这在环境部署、服务扩容等方面具有重大作用。&lt;/p&gt;

&lt;h1 id=&quot;registry&quot;&gt;&lt;a href=&quot;#registry&quot;&gt;仓库&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Docker仓库Registry是一个镜像存储和分发的服务。一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。&lt;/p&gt;

&lt;h1 id=&quot;build&quot;&gt;&lt;a href=&quot;#build&quot;&gt;构建&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;利用 &lt;a href=&quot;https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#run&quot;&gt;Dockerfile&lt;/a&gt; 定制镜像时，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;docker build&lt;/code&gt;命令，将指令构建为文件系统。&lt;/p&gt;

&lt;h1 id=&quot;host&quot;&gt;&lt;a href=&quot;#host&quot;&gt;宿主机&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;宿主机就是运行Docker容器的机器。例如我在mac上用&lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker for Mac&lt;/a&gt;，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;docker pull ubuntu&lt;/code&gt;来拉取一个ubuntu镜像然后运行，那么宿主机指的是mac。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP异步任务队列管理器asyntask介绍</title>
   <link href="http://spetacular.github.io/2017/03/09/asyntask-desc.html"/>
   <updated>2017-03-09T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/03/09/asyntask-desc</id>
   <content type="html">&lt;h1 id=&quot;phpasyntask&quot;&gt;PHP异步任务队列管理器asyntask&lt;/h1&gt;
&lt;p&gt;asyntask是一个轻量级异步任务队列管理器，支持实时，定时，长时和周期任务。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;项目由来&lt;/h2&gt;

&lt;p&gt;本项目最初用于通知推送。例如用户发布评论，需要推送一条push给原作者。而到苹果的服务器的请求时间较长，如果等待苹果服务器的返回结果，则整个发布评论的接口的响应时间就太长了。因为推送push早1秒晚1秒对用户基本没影响，所以当用户发布评论时，只要数据到数据库，即可返回。与此同时创建一条异步任务，在1秒内给用户推送push。这样既保证了接口的响应速度，又不影响用户体验。该项目已经在线上环境运行1年多，执行了累计8千万条命令，运行稳定。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;优点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;异步执行&lt;/li&gt;
  &lt;li&gt;集成管理后台，可视化操作&lt;/li&gt;
  &lt;li&gt;代码集成，可编程&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;缺点&lt;/h2&gt;

&lt;p&gt;并非真正实时，秒级误差。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;安装&lt;/h1&gt;
&lt;p&gt;## 下载源码&lt;/p&gt;

&lt;p&gt;直接使用：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
git clone https://github.com/spetacular/asyntask.git
&lt;/code&gt;
命令下载到本地。&lt;/p&gt;

&lt;p&gt;也可以点击 &lt;a href=&quot;https://github.com/spetacular/asyntask/archive/master.zip&quot;&gt;https://github.com/spetacular/asyntask/archive/master.zip&lt;/a&gt; 下载最新内容的压缩包，然后解压。
## 通过 composer 来安装&lt;/p&gt;

&lt;p&gt;在你的 composer 项目中的 composer.json 文件中，添加这部分：
&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;require&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
           &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;davidyan/asyntask&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;gt;=1.0&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;composer install&lt;/code&gt;。调用示例如下：
```
include ‘./vendor/autoload.php’;
$task = new AsynTask\Task();&lt;/p&gt;

&lt;p&gt;//添加单次任务
$name = ‘单次任务’;
$cmd = ‘php abcd.php’;
$params = array(
	‘params’=&amp;gt;1
);
$task-&amp;gt;add_once_task($name,$cmd,$params);
```&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;配置&lt;/h1&gt;
&lt;p&gt;1.asyntask的数据默认存储在Mysql数据库里，因此需要更改config.php里的配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	'DB_HOST'=&amp;gt;'127.0.0.1',
	'DB_NAME' =&amp;gt; 'asyntask',
	'DB_USER' =&amp;gt; 'root',
	'DB_PWD' =&amp;gt; '',
	'DB_PORT' =&amp;gt; '3306',
	'DB_CHARSET' =&amp;gt; 'utf8mb4',
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.导入数据表
将resource文件夹里的db.sql导入数据库中。&lt;/p&gt;

&lt;p&gt;3.配置健康检查脚本
run.sh定期检查异步任务的运行状况，如果挂了，cron_asyn_task.php脚本。
&lt;code class=&quot;highlighter-rouge&quot;&gt;
chmod +x run.sh
&lt;/code&gt;
然后配置CronTab。运行&lt;code class=&quot;highlighter-rouge&quot;&gt;crontab -e&lt;/code&gt;，然后添加一行：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
* * * * *  path-to/run.sh  &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;
# 使用方式&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;管理后台&lt;/h2&gt;

&lt;p&gt;自带管理后台，可以轻松添加、编辑、删除、搜索任务。代码在&lt;a href=&quot;https://github.com/spetacular/asynadmin&quot;&gt;https://github.com/spetacular/asynadmin&lt;/a&gt;，请自行部署。
&lt;a href=&quot;https://github.com/spetacular/asynadmin/raw/master/asynadmin.jpeg&quot;&gt;&lt;img src=&quot;https://github.com/spetacular/asynadmin/raw/master/asynadmin.jpeg&quot; alt=&quot;管理后台截图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;编程方式&lt;/h2&gt;

&lt;p&gt;可以集成到项目中，完整使用示例见&lt;code class=&quot;highlighter-rouge&quot;&gt;test.php&lt;/code&gt;。
例如添加周期任务：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
$name = '周期任务';
$cmd = 'php abc.php';
$params = array(
	'params'=&amp;gt;1
);
$timeOptions = array(
	'day'=&amp;gt;1,
	'hour'=&amp;gt;2,
	'minute'=&amp;gt;3
);
$task-&amp;gt;add_loop_task($name,$cmd,$params,$timeOptions);
&lt;/code&gt;
## 周期任务示例&lt;/p&gt;

&lt;p&gt;每天执行：day 1 hour 0 minute 0 每天零点执行&lt;/p&gt;

&lt;p&gt;每小时执行：day 0 hour 1 minute 5 每小时的5分执行&lt;/p&gt;

&lt;p&gt;每隔若干分钟执行：day 0 hour 0 minute 5 每隔5分钟执行&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Restful API中的JSON模板解析－JSONOut库的介绍</title>
   <link href="http://spetacular.github.io/2016/08/01/json-template-to-json.html"/>
   <updated>2016-08-01T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/08/01/json-template-to-json</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;项目地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spetacular/jsonout&quot;&gt;Restful API中的JSON模板解析&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;json&quot;&gt;为什么需要JSON模板解析&lt;/h2&gt;

&lt;p&gt;Restful API的两个重要因素是输入和输出，一个好的API要求输入和输出都清晰可见。
输入包括用户提交的方式、参数等，都是可预期的。尽量不要采用数组接收。例如以下的例子，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$data = $_POST;
$User-&amp;gt;save($data);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的坏处一是无法过滤用户非法、多余的参数提交；二是参数不明，后续无法维护。&lt;/p&gt;

&lt;p&gt;输出则要求仅提供满足需要的最小的数据集。例如如下的例子，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$user = User::get(1);
echo $user-&amp;gt;toJson();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的坏处一是输出的内容不清晰，只有知道数据表的结构才能了解输出的内容；二是可能一不小心把用户表敏感字段（密码，手机号）输出，造成信息泄漏。&lt;/p&gt;

&lt;h2 id=&quot;jsonout&quot;&gt;JSONOut库介绍&lt;/h2&gt;

&lt;p&gt;解决输出的方法，是采用JSON模板解析的方法。例如用户表有id,name,pass,avatar,phone字段，其中只有name,avatar是需要输出的。那么模板可以这样定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;avatar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当输出用户数据时，仅保留name和avatar，其它字段自动过滤掉。&lt;/p&gt;

&lt;p&gt;优点是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输出结构一目了然&lt;/li&gt;
  &lt;li&gt;仅保留满足需要的最小的数据集&lt;/li&gt;
  &lt;li&gt;敏感字段自动过滤，减少信息泄露&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class JSONOut
{
	/**
	*按照JSON模板输出JSON数据
	*@param data 源数据
	*@param tplContent JSON模板内容
	*@param multi 是否为多条内容，默认单条
	*@return string
	*/
	public static function toJSON($data, $tplContent,$multi = false){
        if(empty($data)){
            return array();
        }
     
        $tplData = json_decode($tplContent,true);
        if(!$tplData){
            return false;
        }

        $array = array();
        if (!$multi) {
            // 一维数组
            $array = self::array_intersect_key_recursive($data,$tplData);
        } else {
            // 多维数组
            foreach($data as $key =&amp;gt; $value){
                $array[$key] = self::array_intersect_key_recursive($value,$tplData);
            }
        }

        return json_encode($array);
    }


    private static function array_intersect_key_recursive(array $array1, array $array2) {
        $array1 = array_intersect_key($array1, $array2);

        foreach ($array1 as $key =&amp;gt; &amp;amp;$value) {
            if (is_array($value) &amp;amp;&amp;amp; is_array($array2[$key])) {
                $value = $this-&amp;gt;array_intersect_key_recursive($value, $array2[$key]);
            }
        }
        return $array1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;测试代码&lt;/h2&gt;

&lt;p&gt;测试代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$tplContent = &amp;lt;&amp;lt;&amp;lt;EOT
{
  &quot;name&quot;: &quot;&quot;,
  &quot;avatar&quot;: &quot;&quot;
}
EOT;

//单条数据
$user  = array('id'=&amp;gt;1,'name' =&amp;gt; 'david','pass' =&amp;gt; '123456','phone'=&amp;gt;'13888888888','avatar' =&amp;gt; 'http://spetacular.github.io/images/favicon.ico');

echo JSONOut::toJSON($user,$tplContent,false);

echo &quot;\n&quot;;

//多条数据
$users  = [array('id'=&amp;gt;1,'name' =&amp;gt; 'david','pass' =&amp;gt; '123456','phone'=&amp;gt;'13888888888','avatar' =&amp;gt; 'http://spetacular.github.io/images/favicon.ico'),
array('id'=&amp;gt;2,'name' =&amp;gt; 'john','pass' =&amp;gt; '654321','phone'=&amp;gt;'13888888889','avatar' =&amp;gt; 'http://spetacular.github.io/images/favicon.png')];

echo JSONOut::toJSON($users,$tplContent,true);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试结果如下：&lt;/p&gt;

&lt;p&gt;单条数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;david&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;avatar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://spetacular.github.io/images/favicon.ico&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;多条数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
  {
    &quot;name&quot;: &quot;david&quot;,
    &quot;avatar&quot;: &quot;http://spetacular.github.io/images/favicon.ico&quot;
  },
  {
    &quot;name&quot;: &quot;john&quot;,
    &quot;avatar&quot;: &quot;http://spetacular.github.io/images/favicon.png&quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##未来扩展
注意到JSON模板仅有key，没有value，未来可以在value上扩展，比如默认值，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;gender&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果数据里没有gender的数据，则默认为0；&lt;/p&gt;

&lt;p&gt;或者在value上加过滤函数，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;int&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;表示age要转化为整型数字。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Git使用Tips</title>
   <link href="http://spetacular.github.io/2016/07/31/git-sample.html"/>
   <updated>2016-07-31T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/07/31/git-sample</id>
   <content type="html">&lt;h1 id=&quot;git-clone-&quot;&gt;git clone 重命名文件夹&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/user/userApp.git name_you_want
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;git--push403&quot;&gt;git 多账户下 push出现403错误&lt;/h1&gt;
&lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin master&lt;/code&gt;时出现如下错误：
&amp;gt;remote: Permission to spetacular/asyntask.git denied to someone.
&amp;gt;fatal: unable to access ‘https://github.com/spetacular/asyntask.git/’: The requested URL returned error: 403&lt;/p&gt;

&lt;p&gt;这是由于.git/config的[remote “origin”]配置错误。可以更改此处代码。格式可以为以下两种情况：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
url=https://spetacular@github.com/spetacular/asyntask.git
url=ssh://git@github.com/spetacular/asyntask.git
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果不想更改全局配置，而只想临时使用：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
git push https://spetacular@github.com/spetacular/asyntask.git master
&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;git-&quot;&gt;git 设置和取消网络代理&lt;/h1&gt;
&lt;p&gt;可设置为shadowsocks代理：
```
git config –global https.proxy http://127.0.0.1:1080&lt;/p&gt;

&lt;p&gt;git config –global https.proxy https://127.0.0.1:1080&lt;/p&gt;

&lt;p&gt;git config –global –unset http.proxy&lt;/p&gt;

&lt;p&gt;git config –global –unset https.proxy
```&lt;/p&gt;

&lt;h1 id=&quot;git-tag&quot;&gt;git 更新特定tag&lt;/h1&gt;
&lt;p&gt;已经打过tag，但又发现需要微调，再次&lt;code class=&quot;highlighter-rouge&quot;&gt;git tag  1.0.0&lt;/code&gt;时，会发生如下错误
&amp;gt;fatal: tag ‘1.0.0’ already exists&lt;/p&gt;

&lt;p&gt;1.删除本地tag:
&lt;code class=&quot;highlighter-rouge&quot;&gt;
 git tag -d 1.0.0
&lt;/code&gt;
2.重新打tag：
 &lt;code class=&quot;highlighter-rouge&quot;&gt;
 git tag  1.0.0
&lt;/code&gt;
3.push到服务器
 &lt;code class=&quot;highlighter-rouge&quot;&gt;
 git push --force origin refs/tags/1.0.0:refs/tags/1.0.0
&lt;/code&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Leetcode 344. Reverse String - 反转字符串</title>
   <link href="http://spetacular.github.io/2016/07/25/reverse-string.html"/>
   <updated>2016-07-25T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/07/25/reverse-string</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;题目名称&lt;/h2&gt;

&lt;p&gt;Reverse String （反转字符串）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;题目地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-string/&quot;&gt;https://leetcode.com/problems/reverse-string/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;英文：Write a function that takes a string as input and returns the string reversed.&lt;/p&gt;

&lt;p&gt;Example:
Given s = “hello”, return “olleh”.&lt;/p&gt;

&lt;p&gt;中文：反转一个字符串。例如”hello”，转化为”olleh”。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解法&lt;/h2&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    func reverseString(s: String) -&amp;gt; String {
        var len = s.characters.count
        var sArr  = [Character](count:len, repeatedValue:&quot; &quot;)
        for i in s.characters{
            sArr[--len] = i
        }
        
        return String(sArr)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;算法复杂度为O(N)。&lt;/p&gt;

&lt;p&gt;还有一种时间复杂度为O(N/2)的解法，即交换与中心对称位置的字符，这样可以只循环N/2次。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Leetcode 110. Balanced Binary Tree - 判断是否为平衡二叉树（递归解法）</title>
   <link href="http://spetacular.github.io/2016/07/25/balanced-tree.html"/>
   <updated>2016-07-25T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/07/25/balanced-tree</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;题目名称&lt;/h2&gt;

&lt;p&gt;Balanced Binary Tree （判断是否为平衡二叉树）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;题目地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/balanced-binary-tree/&quot;&gt;https://leetcode.com/problems/balanced-binary-tree/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;英文：Given a binary tree, determine if it is height-balanced.&lt;/p&gt;

&lt;p&gt;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.&lt;/p&gt;

&lt;p&gt;中文：给一个二叉树，判断是否为平衡二叉树。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解法&lt;/h2&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    
    func getHeight(root: TreeNode?) -&amp;gt; Int{
        if root == nil {
            return 0
        }
        var leftCount = 0;
        var rightCount = 0;
        if root!.left != nil{
            leftCount = getHeight(root!.left) + 1
        }
        
        if root!.right != nil{
            rightCount = getHeight(root!.right) + 1
        }
        
        return leftCount &amp;gt; rightCount ? leftCount : rightCount
        
    }
    
    
    func isBalanced(root: TreeNode?) -&amp;gt; Bool {
        if root == nil {
            return true
        }
        var leftCount = root!.left == nil ? 0:getHeight(root!.left)+1
        var rightCount = root!.right == nil ? 0:getHeight(root!.right)+1
        if abs(leftCount-rightCount) &amp;gt; 1{
            return false
        }else if !isBalanced(root!.left) || !isBalanced(root!.right){
            return false
        }else{
            return true
        }
        
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试用例示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/balanced_tree_test_case.jpg&quot; alt=&quot;平衡二叉树测试用例&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class TreeNode {
     public var val: Int
     public var left: TreeNode?
     public var right: TreeNode?
     public init(_ val: Int) {
         self.val = val
         self.left = nil
         self.right = nil
     }
}

//[1,null,2,null,3]
var r1 = TreeNode(1)
var r2 = TreeNode(2)
var r3 = TreeNode(3)
r1.right = r2
r2.right = r3
var s = Solution()
s.isBalanced(r1)//false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>Leetcode 172. Factorial Trailing Zeroes - 阶乘后缀0的数目（O(N)与O(logN)解法）</title>
   <link href="http://spetacular.github.io/2016/07/24/factorial-trailing-zeroes.html"/>
   <updated>2016-07-24T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/07/24/factorial-trailing-zeroes</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;题目名称&lt;/h2&gt;

&lt;p&gt;Factorial Trailing Zeroes （阶乘后缀0的数目）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;题目地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/factorial-trailing-zeroes/&quot;&gt;https://leetcode.com/problems/factorial-trailing-zeroes/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;英文：Given an integer n, return the number of trailing zeroes in n!. &lt;br /&gt;
Note: Your solution should be in logarithmic time complexity.&lt;/p&gt;

&lt;p&gt;中文：给一个整型数字n，返回n!后缀0的数目。需要对数级别的时间复杂度。&lt;/p&gt;

&lt;p&gt;例如：10! = 3628800，后缀有两个0，返回2。&lt;/p&gt;

&lt;h2 id=&quot;on&quot;&gt;解法1 O(N)&lt;/h2&gt;
&lt;p&gt;首先是不太可能直接计算n!，然后看后缀0的数目，因为n!太大了！&lt;br /&gt;
我们先用笨办法，先算出前25个数字的结果，看能否找到规律。&lt;br /&gt;
&lt;img src=&quot;http://spetacular.github.io/images/2016/zeros.png&quot; alt=&quot;n!与后缀0数目的关系&quot; /&gt;
可以看到，后缀0数目发生变化的点，都是5的整数倍，如5，10，15，20，25…
这容易理解，产生后缀0，只能是与10相乘，而10 ＝ 2 * 5，2广泛存在于偶数中，所以不用关注。只需要知道5的倍数的整数即可。&lt;/p&gt;

&lt;p&gt;给定整数n，要找到以下数字，其中x*5^y &amp;lt;= n：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5,10,15,...,x*5^y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后看每个数字能分解出y个5:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1,1,1,...,y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后的结果就是如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sum(1,1,1,...,y)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    func trailingZeroes(n: Int) -&amp;gt; Int {
        if n &amp;lt; 5{
            return 0
        }
        var i = 5
        var ret = 0
        while i &amp;lt;= n{
            ret += num_of_five(i)
            i += 5
        }
        return ret
    }
    
    func num_of_five(n: Int) -&amp;gt;(Int) {
        var i = n
        var ret = 0
      
        while i &amp;gt; 0{
            if i % 5 != 0 {
                break
            }
            i = i / 5
            if i &amp;gt;= 1{
                ret++
            }
        }
        
        return ret
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个算法需要循环(n/5)次，时间复杂度为O(N)，尽管“政治正确”，但不是最好的解法。&lt;/p&gt;

&lt;h2 id=&quot;ologn&quot;&gt;解法2 O(logN)&lt;/h2&gt;

&lt;p&gt;将解法1的过程再回顾下，计算5出现的次数，可以分解看：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;出现5，计数加1；
出现5*5，计数加2；
出现5*5*5，计数加3；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;换个角度看，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;除以5，计数加1；
除以5，计数加1；除以5*5，计数加1；
除以5，计数加1；除以5*5，计数加1；除以5*5*5，计数加1；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么最后结果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;floor(n/5) + floor(n/25) + floor(n/125) + ....
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution1 {
    func trailingZeroes(n: Int) -&amp;gt; Int {
        var i = 5
        var ret = 0
        while i &amp;lt;= n{
            ret += n / i
            i *= 5
        }
        return ret
    }
}	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;算法复杂度为O(logN)。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Leetcode 21. Merge Two Sorted Lists - 合并有序链表（递归与非递归解法）</title>
   <link href="http://spetacular.github.io/2016/07/23/merge-two-sorted-lists.html"/>
   <updated>2016-07-23T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/07/23/merge-two-sorted-lists</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;题目名称&lt;/h2&gt;

&lt;p&gt;Merge Two Sorted Lists （合并有序链表）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;题目地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-sorted-lists/&quot;&gt;https://leetcode.com/problems/merge-two-sorted-lists/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;英文：Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;

&lt;p&gt;中文：有两个有序链表，将之合并为一个有序链表。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解法1 递归&lt;/h2&gt;
&lt;p&gt;合并过程是这样的：先比较两个链表的头节点，节点值小的先摘到新链表中；然后再处理剩下的链表，直到两个链表都为空。递归解法比较容易实现。&lt;/p&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    func mergeTwoLists(l1: ListNode?, _ l2: ListNode?) -&amp;gt; ListNode? {
        if l1 == nil{
            return l2
        }
        if l2 == nil{
            return l1
        }
        var ret: ListNode?
        if l1!.val &amp;gt; l2!.val{
            ret = l2
            ret!.next = mergeTwoLists(l1,l2!.next)
        } else {
            ret = l1
            ret!.next = mergeTwoLists(l1!.next,l2)
        }
        return ret
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;解法2 非递归&lt;/h2&gt;
&lt;p&gt;也可以用while循环来做。就是用一个tail指针遍历两个链表，每次走到值较小的节点上，直到其中一个链表走到头。最后拼上另一个链表即可。&lt;/p&gt;

&lt;p&gt;算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    func mergeTwoLists(l1: ListNode?, _ l2: ListNode?) -&amp;gt; ListNode? {
        if l1 == nil{
            return l2
        }
        if l2 == nil{
            return l1
        }
        var head: ListNode?
        var tail: ListNode?
        var ll1 = l1
        var ll2 = l2
        if l1!.val &amp;gt; l2!.val{
            head = l2
            ll2 = l2!.next
        }else{
            head = l1
            ll1 = l1!.next
        }
        tail = head
        head?.next = tail
        while ll1 != nil &amp;amp;&amp;amp; ll2 != nil{
            if ll1!.val &amp;gt; ll2!.val{
                tail?.next = ll2
                tail = ll2
                ll2 = ll2?.next
            }else{
                tail?.next = ll1
                tail = ll1
                ll1 = ll1?.next
            }
        }
        if ll1 == nil{
            tail?.next = ll2
        }
        if ll2 == nil{
            tail?.next = ll1
        }
        return head
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假设l1长度为M，l2长度为N，则算法复杂度为O(M+N)。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Leetcode 258. Add Digits - 非负整数各位相加（另外一个解法）</title>
   <link href="http://spetacular.github.io/2016/07/22/leetcode-258-add-digits.html"/>
   <updated>2016-07-22T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/07/22/leetcode-258-add-digits</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;题目名称&lt;/h2&gt;

&lt;p&gt;Add Digits （非负整数各位相加）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;题目地址&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-digits&quot;&gt;https://leetcode.com/problems/add-digits&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;英文：Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.&lt;/p&gt;

&lt;p&gt;中文：有一个非负整数num，重复这样的操作：对该数字的各位数字求和，对这个和的各位数字再求和……直到最后得到一个仅1位的数字（即小于10的数字）。&lt;/p&gt;

&lt;p&gt;例如：num=38，3+8=11,1+1=2。因为2小于10，因此返回2。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;解法1&lt;/h2&gt;
&lt;p&gt;该算法有一个O(1)复杂度的&lt;a href=&quot;http://my.oschina.net/Tsybius2014/blog/497645&quot; title=&quot;LeetCode：Add Digits - 非负整数各位相加&quot;&gt;《解法》&lt;/a&gt;。其中的公式为 (num - 1) % 9 + 1。这里引用一下这个公式的推导过程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;假设输入的数字是一个5位数字num，则num的各位分别为a、b、c、d、e。有如下关系：num = a * 10000 + b * 1000 + c * 100 + d * 10 + e  
即：num = (a + b + c + d + e) + (a * 9999 + b * 999 + c * 99 + d * 9)  
因为 a * 9999 + b * 999 + c * 99 + d * 9 一定可以被9整除，因此num模除9的结果与 a + b + c + d + e 模除9的结果是一样的。  
对数字 a + b + c + d + e 反复执行同类操作，最后的结果就是一个 1-9 的数字加上一串数字，最左边的数字是 1-9 之间的，右侧的数字永远都是可以被9整除的。  
这道题最后的目标，就是不断将各位相加，相加到最后，当结果小于10时返回。因为最后结果在1-9之间，得到9之后将不会再对各位进行相加，因此不会出现结果为0的情况。因为 (x + y) % z = (x % z + y % z) % z，又因为 x % z % z = x % z，因此结果为 (num - 1) % 9 + 1，只模除9一次，并将模除后的结果加一返回。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个公式是正确的，但这个推导过程有待商榷。为什么要num要先减1，最后再加上1？&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;解法2&lt;/h2&gt;
&lt;p&gt;其实还有一个更容易的理解的解法。推导过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;假设输入的数字是一个5位数字num，则num的各位分别为a、b、c、d、e。有如下关系：num = a * 10000 + b * 1000 + c * 100 + d * 10 + e  
即：num = (a + b + c + d + e) + (a * 9999 + b * 999 + c * 99 + d * 9)  
因为 a * 9999 + b * 999 + c * 99 + d * 9 一定可以被9整除，因此num模除9的结果与 a + b + c + d + e 模除9的结果是一样的。
所以最后的结果是：num % 9.
但是这个结果需要修正一下：如果num能被9整除，则结果为0，这时应该修正为9.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后整个算法代码（swift）如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
    func addDigits(num: Int) -&amp;gt; Int {
        if num == 0 {
            return 0
        }
        var mod = num % 9
        if mod == 0 {
            return 9
        }else{
            return mod
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;算法复杂度也为O(1)。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>PHP性能监控问题记录之二－session与gc过程</title>
   <link href="http://spetacular.github.io/2016/06/16/session-and-gc.html"/>
   <updated>2016-06-16T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/06/16/session-and-gc</id>
   <content type="html">&lt;h2 id=&quot;sessionstartgc&quot;&gt;session_start与gc垃圾回收过程&lt;/h2&gt;
&lt;p&gt;在调性能时，偶然发现有个session函数（ThinkPHP/Common/functions.php）耗时很大。查了一下，ThinkPHP框架默认开启了session，就是每次请求都会调用session_start。 这里面存在问题。&lt;br /&gt;
因为在PHP中, 如果使用file_handler作为Session的save handler, 那么就有概率在每次session_start的时候运行Session的Gc过程。详见&lt;a href=&quot;http://www.laruence.com/2011/03/29/1949.html&quot;&gt;鸟哥的分析&lt;/a&gt;。&lt;br /&gt;
这样就造成每隔一段时间，session函数这里触发了Gc过程，就变慢了。&lt;/p&gt;

&lt;p&gt;解决方法是将session_start默认关闭，需要时再打开。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'SESSION_AUTO_START'=&amp;gt;false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP性能监控问题记录之一－安装配置php-apm</title>
   <link href="http://spetacular.github.io/2016/06/15/problem-tips.html"/>
   <updated>2016-06-15T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/06/15/problem-tips</id>
   <content type="html">&lt;h2 id=&quot;php-apm&quot;&gt;php-apm是什么&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/patrickallaert/php-apm&quot;&gt;php-apm&lt;/a&gt;是一个PHP的性能检测工具，它能方便地捕捉到错误信息，并提供错误追踪回溯，获取请求的统计内存、CPU、响应时间的统计信息，并提供&lt;a href=&quot;https://github.com/patrickallaert/php-apm-web&quot;&gt;可视化的展示&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;apm&quot;&gt;安装apm&lt;/h2&gt;
&lt;p&gt;安装apm有两种方式：从PECL安装，或从源码编译。这里采用PECL安装。源码编译见&lt;a href=&quot;https://github.com/patrickallaert/php-apm#from-source&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo pecl install apm
WARNING: channel &quot;pecl.php.net&quot; has updated its protocols, use &quot;pecl channel-update pecl.php.net&quot; to update
downloading APM-2.0.5.tgz ...
Starting to download APM-2.0.5.tgz (31,484 bytes)
.........done: 31,484 bytes
14 source files, building
running: phpize
Configuring for:
PHP Api Version:         20131106
Zend Module Api No:      20131226
Zend Extension Api No:   220131226
Enable Sqlite3 support [yes] : no
Enable MariaDB/MySQL support [yes] : yes
Enable Socket support [yes] : yes
Enable Statsd support [yes] : yes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;出现了如下错误：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;configure: error: Cannot find MySQL header files
ERROR: `/tmp/pear/temp/APM/configure --with-php-config=/usr/bin/php-config --with-sqlite3=no --with-mysql --enable-socket=yes --enable-statsd=yes' failed
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要安装下mysql dev&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install mysql-client libmysqlclient-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;apm-1&quot;&gt;配置apm&lt;/h2&gt;
&lt;p&gt;在php.ini上配置apm。apm.so依赖于json.so，如果之前没有加载，则应先加载。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension=json.so
extension=apm.so
;;;;;;;;;;;;;;;;;;;
; Module Settings ;
;;;;;;;;;;;;;;;;;;;

;apm
apm.mysql_enabled=1
; Error reporting level specific to the MariaDB/MySQL driver, same level as for PHP's *error_reporting*
apm.mysql_error_reporting=E_ALL|E_STRICT
apm.mysql_stats_enabled=1
apm.mysql_host=localhost
apm.mysql_port=3306
apm.mysql_user=apm
apm.mysql_pass=apm
apm.mysql_db=apm
apm.socket_enabled=0
apm.socket_stats_enabled=0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后重启php，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service php5-fpm restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;apm-web&quot;&gt;部署apm-web&lt;/h2&gt;
&lt;p&gt;apm提供了一个web端查看的项目，地址为：&lt;a href=&quot;https://github.com/patrickallaert/php-apm-web&quot;&gt;https://github.com/patrickallaert/php-apm-web&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;将&lt;a href=&quot;https://github.com/patrickallaert/php-apm-web/archive/master.zip&quot;&gt;https://github.com/patrickallaert/php-apm-web/archive/master.zip&lt;/a&gt;解压后上传到网站根目录，或者如果使用git，可以clone到网站根目录下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/patrickallaert/php-apm-web.git apm-web
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后编辑config/db.php文件。如果选用mysql，可以如下配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return new PDO(&quot;mysql:host=localhost;dbname=apm&quot;, &quot;apm&quot;, &quot;apm&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后的效果如下：&lt;/p&gt;

&lt;p&gt;返回Error的请求列表
&lt;img src=&quot;http://spetacular.github.io/images/2016/web_apm_faulty.png&quot; alt=&quot;返回Error的请求列表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击每一列，都会出现请求的URL、时间、内存、CPU使用情况，以及错误信息。
&lt;img src=&quot;http://spetacular.github.io/images/2016/web_apm_e_error.png&quot; alt=&quot;错误信息&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击错误信息，会出现该错误的Stacktrace。
&lt;img src=&quot;http://spetacular.github.io/images/2016/web_apm_stacktrace.png&quot; alt=&quot;错误追踪回溯&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有详细的访问统计日志。
&lt;img src=&quot;http://spetacular.github.io/images/2016/web_apm_stats.png&quot; alt=&quot;访问日志&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;常见问题&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;问题1 部署后无数据，且扩展未加载。&lt;/h3&gt;

&lt;p&gt;检测php.ini文件，看是否有apm扩展。如果出现类似如下的信息，则说明扩展已加载。
&lt;img src=&quot;http://spetacular.github.io/images/2016/php_ini_apm.png&quot; alt=&quot;php.ini文件&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;问题2 部署后无数据，扩展已加载。&lt;/h3&gt;

&lt;p&gt;mysql_stats_enabled默认值为0，这时是不收集的。可以设置apm.mysql_stats_enabled=1。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>社交网站:热门内容排名算法浅议</title>
   <link href="http://spetacular.github.io/2016/02/15/sns-hot-feed-ranking-algorithm.html"/>
   <updated>2016-02-15T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/02/15/sns-hot-feed-ranking-algorithm</id>
   <content type="html">&lt;p&gt;热门内容对任何网站都很重要，对社交网站更为重要。如何让用户第一眼就看到感兴趣的内容而留下来，正是各种排名算法的任务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/top-10.png&quot; alt=&quot;热门 top 10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设计一个好的排名算法，需要考虑的因素很多，其中最重要的是以下两点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;社区属性及内容属性&lt;/li&gt;
  &lt;li&gt;网站本身内容的量级与更新频率&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者决定采用何种排名算法，后者确定排名的上升与下降速度。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;影响因素&lt;/h1&gt;

&lt;h2 id=&quot;section-1&quot;&gt;社区属性及内容属性&lt;/h2&gt;
&lt;p&gt;社交网站产生许多用户上传的内容，对这些内容进行排名时，需要考虑内容本身的信息。&lt;/p&gt;

&lt;p&gt;从类型上，UGC内容主要是图片、文章、音频还是视频？一般来说，图片扫一眼，文章读一遍，音频听一次，视频看一遍,占用用户的时间依次增加,留住用户的成本也随之增加。&lt;/p&gt;

&lt;p&gt;从特征上，单图或多图？段子还是长文？一首歌还是一集Podcast？短视频还是长视频？越复杂的形式，用户付出的时间成本越大。&lt;/p&gt;

&lt;p&gt;用户付出了时间，那么会要求回报。网站回报用户的东西，无外乎兴趣和价值。而兴趣和价值，是两条不同方向的岔路，通向不同的排名算法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/cross-road.jpg&quot; alt=&quot;排名算法&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;网站本身内容的量级与更新频率&lt;/h2&gt;

&lt;p&gt;内容的量级，像大象与蚂蚁，体量越大，系统越复杂。从海量内容中挑选出热门内容，需要更多的参数和指标。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/ele-ant.jpg&quot; alt=&quot;内容的量级对排名算法影响很大&quot; /&gt;&lt;/p&gt;

&lt;p&gt;更新频率，像流水线与手工作坊，频率越快，产出越多。新内容产生出来后，排名需要很快地上升，才能排到前列，引起注意；旧内容存在一段时间后，排名需要很快地下降，才能让位给新内容。&lt;/p&gt;

&lt;p&gt;所以，需要根据网站本身的内容，确定排名算法需要考虑的参数，以及确定参数的取值。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;兴趣与价值&lt;/h2&gt;
&lt;p&gt;用户留下来，无外乎几种情况：这个东西很有趣（有趣型），或这个东西对我有用（有用型），或者兼而有之。&lt;/p&gt;

&lt;p&gt;有趣的东西，用户第一眼看到就喜欢，但内容本身没有收藏价值。用户的态度是：见之我喜，不见也有其它东西让我喜。例如各种段子、笑话、gif图等。&lt;/p&gt;

&lt;p&gt;有用的内容，用户看后念念不忘，收藏以备以后查看、回味与参考。例如旅游攻略、喜欢的文章、好听的歌曲等。&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;排名如何上升&lt;/h1&gt;
&lt;p&gt;新内容一产生出来就具有上升趋势。&lt;/p&gt;

&lt;p&gt;用户浏览、like（点赞、顶，喜欢）、评论、高评分（星级），编辑推荐等，都会使排名上升。&lt;/p&gt;

&lt;p&gt;有趣型的内容，排名迅速上升，如病毒般地传播开来。
&lt;img src=&quot;http://spetacular.github.io/images/2016/up_1.png&quot; alt=&quot;上升趋势，增速逐渐变小&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有用型的内容，排名逐渐上升，越到后来越多人知道它的价值。
&lt;img src=&quot;http://spetacular.github.io/images/2016/up_2.png&quot; alt=&quot;上升趋势，增速逐渐变大&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;排名如何下降&lt;/h1&gt;

&lt;p&gt;旧内容渐渐呈现下降趋势。&lt;/p&gt;

&lt;p&gt;少有访问、dislike（讨厌、踩，反对）、低评分（星级）、编辑降权，都会使排名下降。&lt;/p&gt;

&lt;p&gt;有趣型的内容，排名维持了一段新鲜期后，大部分用户就失去兴趣了。
&lt;img src=&quot;http://spetacular.github.io/images/2016/down_1.png&quot; alt=&quot;下降趋势，增速逐渐变大&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有用型的内容，排名虽然下降了，但其价值还在，还会不断有人关注。
&lt;img src=&quot;http://spetacular.github.io/images/2016/down_2.png&quot; alt=&quot;下降趋势，增速逐渐变小&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;没有银弹&lt;/h1&gt;
&lt;p&gt;知名博主阮一峰发表了6篇&lt;a href=&quot;http://www.ruanyifeng.com/blog/it/algorithm/&quot; title=&quot;基于用户投票的排名算法&quot;&gt;基于用户投票的排名算法&lt;/a&gt;的系列文章。这6篇文章剖析了几个网站的排名算法。&lt;/p&gt;

&lt;p&gt;如Delicious采用”过去60分钟内被收藏的次数”进行排名。每过60分钟，就统计一次。它的上升和下降趋势就是阶梯函数式的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/step_function.gif&quot; alt=&quot;阶梯函数&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hacker News采用票数计算排名，并考虑时间因素，分数随着时间逐渐减小。看下降曲线，Hacker News属于有趣型的网站（用户当然可以获得价值，这里指排名算法的类型）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2016/ruanyifeng_hacknews.png&quot; alt=&quot;Hacker News下降趋势&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Stack Overflow属于有用型的网站。一个问题提出后，需要网友的回答、对答案投赞成或反对票、评论。这些内容的完善都需要时间。所以，随着时间的推移，一些问题和答案的价值开始慢慢显露，当你搜索时，Statck Overflow就会给你展示最有用的内容。
&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/40dfde6fjw1f1m9pxx416j20go0lwgov.jpg&quot; alt=&quot;Stack Overflow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;redit也属于有趣型的网站。它的时间因素占主导，就是说任何人发的新内容都比较容易靠前；排名算法中利用了赞成票与反对票的差额，说明有争议（很多人赞成，同时很多人反对）的内容，排名靠后；很多人赞成，很少人反对的内容，排名靠前。阮一峰得出结论：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这决定了Reddit是一个符合大众口味的社区，不是一个很激进、可以展示少数派想法的地方。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这也说明了，没有银弹，要建设什么样的社区，就要采用能体现社区特征的排名算法。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Redis技巧:phpredis扩展安装与升级</title>
   <link href="http://spetacular.github.io/2016/01/29/install-and-upgrade-phpredis-extions.html"/>
   <updated>2016-01-29T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/01/29/install-and-upgrade-phpredis-extions</id>
   <content type="html">&lt;p&gt;为了使用zscan来处理有序集合（Sorted Set）按模式获取数据，需要将phpredis扩展从2.2.4升级到2.2.5以上（最新版本为2.2.7）。&lt;/p&gt;

&lt;p&gt;安装和升级方法：&lt;/p&gt;

&lt;p&gt;1.下载安装扩展&lt;/p&gt;

&lt;p&gt;网址：https://pecl.php.net/package/redis&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  wget https://pecl.php.net/get/redis-2.2.7.tgz
  tar zxvf redis-2.2.7.tgz
  cd redis-2.2.7
  phpize
  ./configure
  make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.检查：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  php -i | grep Redis
  Redis Support =&amp;gt; enabled
  Redis Version =&amp;gt; 2.2.7
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装或升级成功。&lt;/p&gt;

&lt;p&gt;3.重启php5-fpm&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  service php5-fpm restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>Redis技巧:Sorted Set使用</title>
   <link href="http://spetacular.github.io/2015/11/01/redis-zunionstore-tip.html"/>
   <updated>2015-11-01T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2015/11/01/redis-zunionstore-tip</id>
   <content type="html">&lt;p&gt;有序集合(Sorted Set)是Redis一个很重要的数据结构，它用来保存需要排序的数据。例如排行榜，一个班的语文成绩，一个公司的员工工资，一个论坛的帖子等。有序集合中，每个元素都带有score（权重），以此来对元素进行排序。它有三个元素：key、member和score。以语文成绩为例，key是考试名称（期中考试、期末考试等），member是学生名字，score是成绩。&lt;/p&gt;

&lt;p&gt;有序集合有两大基本用途：排序和聚合，以下用几个例子分别说明。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;排序&lt;/h1&gt;
&lt;p&gt;假设老师需要处理期中考试的语文成绩，他做的第一件事是将学生成绩录入系统。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Li Lei成绩70分
  127.0.0.1:6379&amp;gt; ZADD mid_test 70 &quot;Li Lei&quot;
  (integer) 1

  Han Meimei成绩70分
  127.0.0.1:6379&amp;gt; ZADD mid_test 70 &quot;Han Meimei&quot;
  (integer) 1

  tom成绩99.5分
  127.0.0.1:6379&amp;gt; ZADD mid_test 99.5 &quot;Tom&quot;
  (integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###排行榜
有序集合天然就是做排行榜的利器。只需将带score的member塞到有序集合里，就可以正序或倒序取出数据。这要用到ZREVRANGE（倒序）和ZRANGE（正序）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  分数排行榜
  127.0.0.1:6379&amp;gt; ZREVRANGE mid_test 0 -1 WITHSCORES
  1) &quot;Tom&quot;
  2) &quot;99.5&quot;
  3) &quot;Li Lei&quot;
  4) &quot;70&quot;
  5) &quot;Han Meimei&quot;
  6) &quot;70&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###分段统计
有序集合还支持按score区间来查询：ZREVRANGEBYSCORE为倒序查询，ZRANGEBYSCORE为正序。例如要知道90分以上的学霸：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; ZREVRANGEBYSCORE mid_test 100 90 WITHSCORES
  1) &quot;Tom&quot;
  2) &quot;99.5&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;#聚合 
有序集合，其本质是集合，当然会有交集（&lt;a href=&quot;http://redisdoc.com/sorted_set/zinterstore.html&quot; title=&quot;ZINTERSTORE&quot;&gt;ZINTERSTORE&lt;/a&gt;）和并集（&lt;a href=&quot;http://redisdoc.com/sorted_set/zunionstore.html&quot; title=&quot;ZUNIONSTORE&quot;&gt;ZUNIONSTORE&lt;/a&gt;）运算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2015-11-01/inter-union.jpg&quot; alt=&quot;交集和并集&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###交集
&lt;a href=&quot;http://redisdoc.com/sorted_set/zinterstore.html&quot; title=&quot;ZINTERSTORE&quot;&gt;ZINTERSTORE&lt;/a&gt;取所有集合的并集。以两个集合A和B为例，要取交集C，是这样的逻辑：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A和B中共有的member，会加入到C中，其score等于A、B中score之和。&lt;/li&gt;
  &lt;li&gt;不同时在A和B的member，不会加到C中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;某班又进行了期末考试，同时来了个新同学Jerry。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; ZADD fin_test 88 &quot;Li Lei&quot;
  (integer) 1
  127.0.0.1:6379&amp;gt; ZADD fin_test 75 &quot;Han Meimei&quot;
  (integer) 1
  127.0.0.1:6379&amp;gt; ZADD fin_test 99.5 &quot;Tom&quot;
  (integer) 1
  127.0.0.1:6379&amp;gt; ZADD fin_test 100 &quot;Jerry&quot;
  (integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;老师要按期中考试和期末考试的总成绩来排座位，就对mid_test和fin_test做了个交集。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; ZINTERSTORE sum_point 2 mid_test fin_test
  (integer) 3
  127.0.0.1:6379&amp;gt; ZREVRANGE sum_point 0 -1 WITHSCORES
  1) &quot;Tom&quot;
  2) &quot;199&quot;
  3) &quot;Li Lei&quot;
  4) &quot;158&quot;
  5) &quot;Han Meimei&quot;
  6) &quot;145&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果显示了学生的总成绩。
但结果中没有新来的Jerry同学（尽管TA考了100分）。这是坑一。&lt;/p&gt;

&lt;p&gt;###并集
&lt;a href=&quot;http://redisdoc.com/sorted_set/zunionstore.html&quot; title=&quot;ZUNIONSTORE&quot;&gt;ZUNIONSTORE&lt;/a&gt;计算所有集合的并集。以两个集合A和B为例，要取并集C，是这样的逻辑：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A的所有member会加到C中，其score与A中相等&lt;/li&gt;
  &lt;li&gt;B的所有member会加到C中，其score与B中相等&lt;/li&gt;
  &lt;li&gt;A和B中共有的member，其score等于A、B中score之和。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假设某公司要核算工资总支出，先由各部门独自核算，再由财务统一处理。&lt;/p&gt;

&lt;p&gt;程序员工资&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; zadd programmer 2000 peter
  (integer) 1
  127.0.0.1:6379&amp;gt; zadd programmer 3500 jack
  (integer) 1
  127.0.0.1:6379&amp;gt; zadd programmer 5000 tom
  (integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;经理工资&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; zadd manager 2000 herry
  (integer) 1
  127.0.0.1:6379&amp;gt; zadd manager 3500 mary
  (integer) 1
  127.0.0.1:6379&amp;gt; zadd manager 4000 tom
  (integer) 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;财务统一处理。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  127.0.0.1:6379&amp;gt; zunionstore salary 2 programmer manager
  (integer) 5
  127.0.0.1:6379&amp;gt; zrange salary 0 -1 withscores
   1) &quot;herry&quot;
   2) &quot;2000&quot;
   3) &quot;peter&quot;
   4) &quot;2000&quot;
   5) &quot;jack&quot;
   6) &quot;3500&quot;
   7) &quot;mary&quot;
   8) &quot;3500&quot;
   9) &quot;tom&quot;
  10) &quot;9000&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果显示了总工资支出情况。&lt;/p&gt;

&lt;p&gt;但结果中程序员tom和经理tom是两个人，但工资算在了一起。这是坑二。&lt;/p&gt;

&lt;p&gt;#避免踩坑&lt;/p&gt;

&lt;p&gt;还记得上面说的坑一和坑二吗？&lt;/p&gt;

&lt;p&gt;坑一：&lt;/p&gt;

&lt;p&gt;当进行ZINTERSTORE操作时，如果进行聚合操作的源集合中元素不同，则聚合后的结果集仅为并集。如果发现聚合后少了一些元素，请查看源集合元素是否相同。&lt;/p&gt;

&lt;p&gt;坑二：&lt;/p&gt;

&lt;p&gt;当进行ZUNIONSTORE操作时，如果进行聚合操作的源集合中有相同元素，则聚合后的结果集中，相同元素的score等于源集合元素的score之和。如果发现聚合后某些元素的score异常，请查看源集合是否有相同元素。&lt;/p&gt;

&lt;p&gt;我踩过的坑：&lt;/p&gt;

&lt;p&gt;做用户的feed（timeline）时，需要将我关注的人和我自己发表的信息聚合起来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://spetacular.github.io/images/2015-11-01/feed-timeline.jpg&quot; alt=&quot;timeline &amp;amp; feed&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应该用ZUNIONSTORE将所有信息聚合到一起。&lt;/p&gt;

&lt;p&gt;后来有用户反馈说timeline排序错误，自己发表发布的信息永远在最上面。后来查明原因，由于早期的bug，自己竟然可以关注自己，导致关注人和自己重复聚合。踩到了坑二。&lt;/p&gt;

&lt;p&gt;#为什么踩坑
以坑二为例，为什么有相同元素时，score就会变成原来元素的和？&lt;/p&gt;

&lt;p&gt;因为ZINTERSTORE和ZUNIONSTORE有个参数为AGGREGATE，表示结果集的聚合方式，可取SUM、MIN、MAX其中之一。默认值为SUM。&lt;/p&gt;

&lt;p&gt;所以不指定聚合方式时，缺省值为SUM，即求和。&lt;/p&gt;

&lt;blockquote&gt;
  默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。
&lt;/blockquote&gt;

&lt;p&gt;文档如上。&lt;/p&gt;

&lt;p&gt;#有序集合之总结&lt;/p&gt;

&lt;p&gt;使用场景：排行榜，有序列表，聚合；&lt;/p&gt;

&lt;p&gt;算法复杂度：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;增删：O(M*log(N))， N 为有序集的基数， M 为被成功操作（新增、移除）的成员的数量。&lt;/li&gt;
  &lt;li&gt;查询：O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。&lt;/li&gt;
  &lt;li&gt;聚合：O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。&lt;/li&gt;
  &lt;li&gt;总数：O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意事项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ZINTERSTORE操作时,如果发现聚合后少了一些元素，请查看源集合元素是否相同。&lt;/li&gt;
  &lt;li&gt;ZUNIONSTORE操作时,如果发现聚合后某些元素的score异常，请查看源集合是否有相同元素。&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Redis技巧:分片技术和Hash Tag</title>
   <link href="http://spetacular.github.io/2015/09/20/redis-hash-tag.html"/>
   <updated>2015-09-20T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2015/09/20/redis-hash-tag</id>
   <content type="html">&lt;p&gt;twitter的 &lt;a href=&quot;https://github.com/twitter/twemproxy&quot;&gt;twemproxy&lt;/a&gt; 是一个Redis的代理服务程序,能够实现key的分片。分片能使key均匀地分布到集群的机器上去，能保证数据的一致性，有着众多的优点。&lt;/p&gt;

&lt;p&gt;但从Redis单实例切换到twemproxy集群时，还是有些需要注意的地方：&lt;/p&gt;

&lt;p&gt;不支持的方法：&lt;/p&gt;

&lt;p&gt;KEYS,MIGRATE,SCAN等&lt;/p&gt;

&lt;p&gt;支持但需特殊处理的方法：&lt;/p&gt;

&lt;p&gt;MSET,SINTERSTORE,SUNIONSTORE,ZINTERSTORE,ZUNIONSTORE等&lt;/p&gt;

&lt;p&gt;全部请查看 &lt;a href=&quot;https://github.com/twitter/twemproxy/blob/master/notes/redis.md&quot;&gt;Redis命令列表&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;对于不支持的方法，在使用时需要寻找替代方案。本文主要解决一下需特殊处理的方法。&lt;/p&gt;

&lt;h3 id=&quot;mset&quot;&gt;MSET&lt;/h3&gt;
&lt;p&gt;单实例上的MSET是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，某些给定 key 被更新而另一些给定 key 没有改变的情况，不可能发生。&lt;/p&gt;

&lt;p&gt;而集群上虽然也支持同时设置多个key，但不再是原子性操作。会存在某些给定 key 被更新而另外一些给定 key 没有改变的情况。其原因是需要设置的多个key可能分配到不同的机器上。&lt;/p&gt;

&lt;p&gt;##SINTERSTORE,SUNIONSTORE,ZINTERSTORE,ZUNIONSTORE&lt;/p&gt;

&lt;p&gt;这四个命令属于同一类型。它们的共同之处是都需要对一组key进行运算或操作，但要求这些key都被分配到相同机器上。&lt;/p&gt;

&lt;p&gt;这就是分片技术的矛盾之处：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;即要求key尽可能地分散到不同机器，又要求某些相关联的key分配到相同机器。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;hash-tags&quot;&gt;Hash Tags&lt;/h3&gt;
&lt;p&gt;解铃还需系铃人。解决方法还是从分片技术的原理上找。&lt;/p&gt;

&lt;p&gt;分片，就是一个hash的过程：对key做md5，sha1等hash算法，根据hash值分配到不同的机器上。&lt;/p&gt;

&lt;p&gt;为了实现将key分到相同机器，就需要相同的hash值，即相同的key（改变hash算法也行，但不简单）。&lt;/p&gt;

&lt;p&gt;但key相同是不现实的，因为key都有不同的用途。例如user:user1:ids保存用户的tweets ID，user:user1:tweets保存tweet的具体内容，两个key不可能同名。&lt;/p&gt;

&lt;p&gt;仔细观察user:user1:ids和user:user1:tweets，两个key其实有相同的地方，即user1。能不能拿这一部分去计算hash呢？&lt;/p&gt;

&lt;p&gt;这就是 &lt;a href=&quot;https://github.com/twitter/twemproxy/blob/master/notes/recommendation.md#hash-tags&quot;&gt;Hash Tag&lt;/a&gt; 。允许用key的部分字符串来计算hash。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当一个key包含 {} 的时候，就不对整个key做hash，而仅对 {} 包括的字符串做hash。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设hash算法为sha1。对user:{user1}:ids和user:{user1}:tweets，其hash值都等同于sha1(user1)。&lt;/p&gt;

&lt;h2 id=&quot;hash-tag-&quot;&gt;Hash Tag 配置&lt;/h2&gt;

&lt;p&gt;Hash Tag是用于hash的部分字符串开始和结束的标记，例如”{}”、”$$”等。
配置时，只需更改hash_tag字段即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;beta:
  listen: 127.0.0.1:22122
  hash: fnv1a_64
  hash_tag: &quot;{}&quot;
  distribution: ketama
  auto_eject_hosts: false
  timeout: 400
  redis: true
  servers:
   - 127.0.0.1:6380:1 server1
   - 127.0.0.1:6381:1 server2
   - 127.0.0.1:6382:1 server3
   - 127.0.0.1:6383:1 server4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Swift知识点纪录</title>
   <link href="http://spetacular.github.io/2015/09/12/swift-records.html"/>
   <updated>2015-09-12T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2015/09/12/swift-records</id>
   <content type="html">&lt;p&gt;po主初学Swift，遇到不少细节知识的缺失，只好请教Google大神。这篇文就是Google的结果，纪录一下。&lt;/p&gt;

&lt;p&gt;##获取UNIX时间戳
即获得到某个时间点到1970年1月1日0点0分0秒的秒数。&lt;/p&gt;

&lt;p&gt;返回字符串格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var Timestamp: String {
    return &quot;\(NSDate().timeIntervalSince1970)&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出时，可以这样调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;println(&quot;Timestamp: \(Timestamp)&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果希望返回NSTimeInterval，则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Timestamp: NSTimeInterval {
    return NSDate().timeIntervalSince1970
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##创建alert
创建Alert的代码。&lt;a href=&quot;http://stackoverflow.com/questions/24272006/how-to-add-action-to-uialertview-in-swift-ios-7&quot; title=&quot;原文链接&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;
func showAlert(){
    var createAccountErrorAlert: UIAlertView = UIAlertView()

    createAccountErrorAlert.delegate = self

    createAccountErrorAlert.title = &quot;Oops&quot;
    createAccountErrorAlert.message = &quot;Could not create account!&quot;
    createAccountErrorAlert.addButtonWithTitle(&quot;Dismiss&quot;)
    createAccountErrorAlert.addButtonWithTitle(&quot;Retry&quot;)

    createAccountErrorAlert.show()
}

func alertView(View: UIAlertView!, clickedButtonAtIndex buttonIndex: Int){

    switch buttonIndex{

    case 1:
        NSLog(&quot;Retry&quot;);
    break;
    case 0:
        NSLog(&quot;Dismiss&quot;);
        break;
    default:
        NSLog(&quot;Default&quot;);
        break;
        //Some code here..

    }
}
&lt;/code&gt;
&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Nginx Sticky的使用及踩过的坑</title>
   <link href="http://spetacular.github.io/2015/08/01/nginx-sticky-problem.html"/>
   <updated>2015-08-01T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2015/08/01/nginx-sticky-problem</id>
   <content type="html">&lt;p&gt;#什么是Sticky？#
为了理解Sticky的工作原理，我们可以先考虑一个问题：负载均衡怎么做？&lt;/p&gt;

&lt;p&gt;DNS解析，在域名解析时分配给不同的服务器IP；&lt;/p&gt;

&lt;p&gt;IP Hash，根据客户端的IP，将请求分配到不同的服务器上；&lt;/p&gt;

&lt;p&gt;cookie，服务器给客户端下发一个cookie，具有特定cookie的请求会分配给它的发行者。&lt;/p&gt;

&lt;p&gt;Sticky就是基于cookie的一种负载均衡解决方案，通过cookie实现客户端与后端服务器的会话保持, 在一定条件下可以保证同一个客户端访问的都是同一个后端服务器。请求来了，服务器发个cookie，并说：下次来带上，直接来找我。&lt;/p&gt;

&lt;p&gt;为方便叙述，文中的cookie都指sticky使用的cookie。&lt;/p&gt;

&lt;p&gt;#Sticky工作原理
Sticky是nginx的一个模块,通过分发和识别cookie，来使同一个客户端的请求落在同一台服务器上。sticky的处理过程如下（假设cookie名称为route）：&lt;/p&gt;

&lt;p&gt;1.客户端首次发起请求，请求头未带route的cookie。nginx接收请求，发现请求头没有route，则以轮询方式将请求分配给后端服务器。&lt;/p&gt;

&lt;p&gt;2.后端服务器处理完请求，将响应头和内容返回给nginx。&lt;/p&gt;

&lt;p&gt;3.nginx生成route的cookie，返回给客户端。route的值与后端服务器对应，可能是明文，也可能是md5、sha1等Hash值。&lt;/p&gt;

&lt;p&gt;4.客户端接收请求，并创建route的cookie。&lt;/p&gt;

&lt;p&gt;5.客户端再次发送请求时，带上route。&lt;/p&gt;

&lt;p&gt;6.nginx接收到route，直接转给对应的后端服务器。&lt;/p&gt;

&lt;p&gt;关于sticky的详细的配置过程在
&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#sticky&quot; title=&quot;nginx sticky详细配置&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;#参数解析&lt;/p&gt;

&lt;p&gt;这里引用淘宝Tengine的文档：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;语法：session_sticky [cookie=name] [domain=your_domain] [path=your_path] [maxage=time] [mode=insert|rewrite|prefix] [option=indirect] [maxidle=time] [maxlife=time] [fallback=on|off] [hash=plain|md5]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认值：session_sticky cookie=route mode=insert fallback=on&lt;/p&gt;

&lt;p&gt;上下文：upstream&lt;/p&gt;

&lt;p&gt;说明:&lt;/p&gt;

&lt;p&gt;本指令可以打开会话保持的功能，下面是具体的参数：&lt;/p&gt;

&lt;p&gt;cookie设置用来记录会话的cookie名称&lt;/p&gt;

&lt;p&gt;domain设置cookie作用的域名，默认不设置&lt;/p&gt;

&lt;p&gt;path设置cookie作用的URL路径，默认不设置&lt;/p&gt;

&lt;p&gt;maxage设置cookie的生存期，默认不设置，即为session cookie，浏览器关闭即失效&lt;/p&gt;

&lt;p&gt;mode设置cookie的模式:&lt;/p&gt;

&lt;p&gt;    insert: 在回复中本模块通过Set-Cookie头直接插入相应名称的cookie。&lt;/p&gt;

&lt;p&gt;    prefix: 不会生成新的cookie，但会在响应的cookie值前面加上特定的前缀，当浏览器带着这个有特定标识的cookie再次请求时，模块在传给后端服务前先删除加入的前缀，后端服务拿到的还是原来的cookie值，这些动作对后端透明。如：”Cookie: NAME=SRV~VALUE”。&lt;/p&gt;

&lt;p&gt;    rewrite: 使用服务端标识覆盖后端设置的用于session sticky的cookie。如果后端服务在响应头中没有设置该cookie，则认为该请求不需要进行session sticky，使用这种模式，后端服务可以控制哪些请求需要sesstion sticky，哪些请求不需要。&lt;/p&gt;

&lt;p&gt;option 设置用于session sticky的cookie的选项，可设置成indirect或direct。indirect不会将session sticky的cookie传送给后端服务，该cookie对后端应用完全透明。direct则与indirect相反。&lt;/p&gt;

&lt;p&gt;maxidle设置session cookie的最长空闲的超时时间&lt;/p&gt;

&lt;p&gt;maxlife设置session cookie的最长生存期&lt;/p&gt;

&lt;p&gt;fallback设置是否重试其他机器，当sticky的后端机器挂了以后，是否需要尝试其他机器&lt;/p&gt;

&lt;p&gt;hash 设置cookie中server标识是用明文还是使用md5值，默认使用md5&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;maxage是cookie的生存期。不设置时，浏览器或App关闭后就失效。下次启动时，又会随机分配后端服务器。所以如果希望该客户端的请求长期落在同一台后端服务器上，可以设置maxage。&lt;/p&gt;

&lt;p&gt;hash不论是明文还是hash值，都有固定的数目。因为hash是server的标识，所以有多少个server，就有等同数量的hash值。&lt;/p&gt;

&lt;p&gt;#一些例外#&lt;/p&gt;

&lt;p&gt;##同一客户端的请求，有可能落在不同的后端服务器上##
如果客户端启动时同时发起多个请求。由于这些请求都没带cookie，所以服务器会随机选择后端服务器，返回不同的cookie。当这些请求中的最后一个请求返回时，客户端的cookie才会稳定下来，值以最后返回的cookie为准。&lt;/p&gt;

&lt;p&gt;##cookie不一定生效##
由于cookie最初由服务器端下发，如果客户端禁用cookie，则cookie不会生效。&lt;/p&gt;

&lt;p&gt;##客户端可能不带cookie##
Android客户端发送请求时，一般不会带上所有的cookie，需要明确指定哪些cookie会带上。如果希望用sticky做负载均衡，请对Android开发说加上cookie。&lt;/p&gt;

&lt;p&gt;#注意事项
* cookie名称不要和业务使用的cookie重名。Sticky默认的cookie名称是route，可以改成任何值。但切记，不可以与业务中使用的cookie重名。
* 客户端发的第一个请求是不带cookie的。服务器下发的cookie，在客户端下一次请求时才能生效。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>日本东京之旅</title>
   <link href="http://spetacular.github.io/2015/06/20/japan-tokyo-journey.html"/>
   <updated>2015-06-20T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2015/06/20/japan-tokyo-journey</id>
   <content type="html">&lt;ul&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/1.jpeg&quot; title=&quot;去的那天，北京天气不错&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/1.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/2.jpeg&quot; title=&quot;首都国际机场&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/2.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/3.jpeg&quot; title=&quot;吃了碗虾仁面，35元&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/3.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/4.jpeg&quot; title=&quot;日航的小飞机&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/4.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/5.jpeg&quot; title=&quot;看建筑都成方块了&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/5.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/6.jpeg&quot; title=&quot;飞在云彩上面&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/6.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/7.jpeg&quot; title=&quot;东京海关&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/7.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;


&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/8.jpeg&quot; title=&quot;坐火车去上野&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/8.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/9.jpeg&quot; title=&quot;车上人很少&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/9.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/10.jpeg&quot; title=&quot;初到上野&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/10.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/11.jpeg&quot; title=&quot;街道&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/11.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/12.jpeg&quot; title=&quot;大和寿司排队中&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/12.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/13.jpeg&quot; title=&quot;等了半个小时，终于可以开吃了&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/13.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/14.jpeg&quot; title=&quot;好吃的寿司&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/14.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/15.jpeg&quot; title=&quot;擦栏杆的工人，很用心的样子&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/15.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/16.jpeg&quot; title=&quot;RKK LINE&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/16.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/17.jpeg&quot; title=&quot;一个公园&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/17.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/18.jpeg&quot; title=&quot;优衣库1&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/18.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/19.jpeg&quot; title=&quot;优衣库2&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/19.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/20.jpeg&quot; title=&quot;优衣库3&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/20.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/21.jpeg&quot; title=&quot;门们&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/21.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/22.jpeg&quot; title=&quot;大桥&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/22.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/23.jpeg&quot; title=&quot;大桥夜景&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/23.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/24.jpeg&quot; title=&quot;自由女神&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/24.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/25.jpeg&quot; title=&quot;银座&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/25.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/26.jpeg&quot; title=&quot;好看的杯子&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/26.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/27.jpeg&quot; title=&quot;美食－扇贝&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/27.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/28.jpeg&quot; title=&quot;美食－寿司，生鱼片&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/28.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/29.jpeg&quot; title=&quot;美食－寿司&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/29.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/30.jpeg&quot; title=&quot;美食汇&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/30.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;


&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/31.jpeg&quot; title=&quot;干一杯&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/31.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/32.jpeg&quot; title=&quot;开吃前先拍照&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/32.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/33.jpeg&quot; title=&quot;早稻田大学－大门太小&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/33.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/34.jpeg&quot; title=&quot;早稻田大学－校园&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/34.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/35.jpeg&quot; title=&quot;近世禅画海报&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/35.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/36.jpeg&quot; title=&quot;好像与日本安保法案有关&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/36.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/37.jpeg&quot; title=&quot;手写海报&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/37.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/38.jpeg&quot; title=&quot;博物馆？&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/38.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/39.jpeg&quot; title=&quot;妹子&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/39.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/40.jpeg&quot; title=&quot;图书馆&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/40.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/41.jpeg&quot; title=&quot;教堂&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/41.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/42.jpeg&quot; title=&quot;为什么不是红十字？&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/42.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/43.jpeg&quot; title=&quot;草坪&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/43.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/44.jpeg&quot; title=&quot;前面就是日本天皇的宫殿&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/44.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/45.jpeg&quot; title=&quot;铺石子的广场&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/45.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/46.jpeg&quot; title=&quot;宫殿不让进&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/46.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/47.jpeg&quot; title=&quot;明治神宫&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/47.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/48.jpeg&quot; title=&quot;苹果店帮同事带iphone，ipad&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/48.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/1000.jpeg&quot; title=&quot;国外有个网站真有意思啊。国内啥时候有？&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/100.png&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;!--&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/.jpeg&quot; title=&quot;&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/.jpeg&quot;&gt;&lt;/a&gt;&lt;/li&gt;--&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/IMG_0085.JPG&quot; title=&quot;靖国神社&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/IMG_0085.JPG&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/IMG_0099.JPG&quot; title=&quot;公共电动车&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/IMG_0099.JPG&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/IMG_0109.JPG&quot; title=&quot;武道馆&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/IMG_0109.JPG&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/IMG_0114.JPG&quot; title=&quot;时钟&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/IMG_0114.JPG&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/IMG_0129.JPG&quot; title=&quot;东京大学&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/IMG_0129.JPG&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/IMG_0009.JPG&quot; title=&quot;挖掘机&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/IMG_0009.JPG&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/IMG_0050.JPG&quot; title=&quot;上野动物园&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/IMG_0050.JPG&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/IMG_0143.JPG&quot; title=&quot;秋叶原&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/IMG_0143.JPG&quot;&gt;&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a class=&quot;gallery&quot; href=&quot;/images/2015-06-20/IMG_0153.JPG&quot; title=&quot;手办&quot;&gt;&lt;img data-original=&quot;/images/2015-06-20/thumb/IMG_0153.JPG&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Restful接口设计：如何做版本兼容</title>
   <link href="http://spetacular.github.io/2015/06/01/how-to-deal-with-version-compatibility.html"/>
   <updated>2015-06-01T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2015/06/01/how-to-deal-with-version-compatibility</id>
   <content type="html">&lt;p&gt;现在App大多采用Restful接口，与服务器完成资源交换。这种实现方式隐藏了服务器端的具体实现，做到了对App端的透明服务。服务器端如何变更，甚至换一种语言实现，只要对外接口不变，App依然不受影响。&lt;/p&gt;

&lt;p&gt;App的升级过程中，版本兼容是一个值得关注的问题，因为App要升级，服务器端的Restful接口也要进化，于是版本兼容要同时兼顾App和服务器端。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;一个例子&lt;/h1&gt;

&lt;p&gt;版本兼容是向下兼容。接口升级后要保证低版本App能正常工作。&lt;/p&gt;

&lt;p&gt;例如“App 1.0”使用了下面接口完成修改用户信息功能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET api.demo.com/modify_userinfo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;采用GET方式提交用户输入。后来发现该接口可被CSRF攻击。&lt;/p&gt;

&lt;p&gt;这时要做两件事：&lt;/p&gt;

&lt;p&gt;第一，服务器接口要为新的“App 1.1”提供升级，需要将GET方式改为POST，并且增加Token验证。这是CSRF的一般防范方法，具体请参看 &lt;a href=&quot;http://drops.wooyun.org/papers/155&quot; title=&quot;CSRF简单介绍及利用方法&quot;&gt;《CSRF简单介绍及利用方法》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;第二，服务器接口要为旧的“App 1.0”版本修复漏洞。但这时App已发布，不可能修改了。这时只能服务器端来改。例如限制user-agent为”App 1.0”的请求才有效，用户通过浏览器提交的请求无效。这样在一定程度上减少了CSRF的危害。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;版本兼容的两种情况&lt;/h1&gt;

&lt;p&gt;从上面的例子来看，版本兼容可分为两种：&lt;/p&gt;

&lt;p&gt;大版本，指版本升级，接口的输入输出可能发生变化。&lt;/p&gt;

&lt;p&gt;小版本，指版本修复，只针对某个版本修改接口，其它接口保持不变。&lt;/p&gt;

&lt;p&gt;这两种情况都很常见。App未发布时，服务器接口从1.0升级到2.0，这时App开发者可以配合一下，使用2.0的接口；但对于已发布的App版本，只能由服务器端针对特定的App版本来修复漏洞。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;如何做&lt;/h1&gt;

&lt;p&gt;App开发者需要配合，在请求接口时传入以下两项信息：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;App版本标识，一般包括App名称、版本、平台（Android、IOS等）、SDK版本等。一般放在user-agent里，例如微信的user-agent如下：&lt;/p&gt;

    &lt;p&gt;Mozilla/5.0 (iPhone; CPU iPhone OS 5_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Mobile/9B176 MicroMessenger/6.2.2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接口版本标识，指采用接口的版本，例如可以在Request Header里加入majarversion=2.0，表明使用的是2.0的接口。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;服务器端开发者需要根据App版本和接口版本标识，来提供向下兼容&lt;/p&gt;

</content>
 </entry>
 
 
</feed>
