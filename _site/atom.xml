<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>David's World</title>
 <link href="http://spetacular.github.io/atom.xml" rel="self"/>
 <link href="http://spetacular.github.io"/>
 <updated>2018-09-08T19:25:23+08:00</updated>
 <id>http://spetacular.github.io</id>
 <author>
   <name>David</name>
   <email>blah@email.test</email>
 </author>

 
 <entry>
   <title>每周学习第 1 期：贝叶斯定理、拼写纠正、生日悖论</title>
   <link href="http://spetacular.github.io/2018/09/08/bayesian-spelling-check-birthday-problem.html"/>
   <updated>2018-09-08T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2018/09/08/bayesian-spelling-check-birthday-problem</id>
   <content type="html">&lt;p&gt;本周天气非常好。
&lt;img src=&quot;/images/2018/african-blue.jpg&quot; alt=&quot;african-blue-sky&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;一贝叶斯定理&quot;&gt;一、贝叶斯定理&lt;/h1&gt;
&lt;p&gt;贝叶斯定理解决的是，在事件B已经发生的情况下，事件A发生的概率。
&lt;img src=&quot;/images/2018/conditional-probability.jpg&quot; alt=&quot;文氏图解决贝叶斯&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最重要的公式有两个:&lt;/p&gt;

&lt;p&gt;贝叶斯公式 
&lt;img src=&quot;/images/2018/a-join-b.png&quot; alt=&quot;贝叶斯公式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;全概率公式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018/full-probability.png&quot; alt=&quot;全概率公式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直观的解释就是，无论是事件B发生情况下，事件A发生，或者事件A发生情况下，事件B发生，其结果都是事件A和事件B同时发生了。反映到文氏图上，就是 A∩B 。&lt;/p&gt;

&lt;h1 id=&quot;二拼写纠正&quot;&gt;二、拼写纠正&lt;/h1&gt;
&lt;p&gt;拼写纠正是一个很常见的功能，比如把 config 拼写成 conf，软件提示输错了，并推荐正确写法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git conf
git: 'conf' is not a git command. See 'git --help'.

Did you mean this?
	config
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此类问题有很多解决方法，贝叶斯是其中之一。贝叶斯方法的思路是，在输入conf的情况下，计算正确值是config或其它单词的概率是多少，并找出概率最大的单词。&lt;/p&gt;

&lt;p&gt;其中的数学原理并不能，但是要解决两个问题：&lt;/p&gt;

&lt;p&gt;1.寻找备选项。如果conf可能是错误的，那么如何找到与conf类似的词如confs、config、confidence等&lt;br /&gt;
2.如何确认备选项的概率&lt;/p&gt;

&lt;p&gt;对于问题1，简单的方法是通过编辑距离找出相近的单词，如增加、减少、替换、更换位置等，找到所有的备选项。&lt;/p&gt;

&lt;p&gt;对于问题2，简单的方法是找一本英文书，分离出所有的单词，计算每个单词出现的次数。&lt;/p&gt;

&lt;h1 id=&quot;三生日悖论&quot;&gt;三、生日悖论&lt;/h1&gt;
&lt;p&gt;在23人中，有2人生日相同的概率大于50%；若有50人，则概率增至97。这可能与人们的直觉相悖，因为一年有365天，两人同天生日，通常就是人们常说的“太巧了”。&lt;/p&gt;

&lt;p&gt;但经过&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%94%9F%E6%97%A5%E5%95%8F%E9%A1%8C#%E6%A6%82%E7%8E%87%E4%BC%B0%E8%AE%A1&quot;&gt;计算&lt;/a&gt;，发现其概率要高得多。
&lt;img src=&quot;/images/2018/birthday-probability.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我写了一段代码来模拟一下，从1到365的数字中，随机取出2个数，算出2个数相同的概率。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main
import &quot;fmt&quot;
import &quot;time&quot;
import &quot;math/rand&quot;

//return a random number of 1~365
func generateBirth() int{
	rand.Seed(time.Now().UnixNano())
	return 1+rand.Intn(364)
}

//check if at least 2 persons have same birthday
func checkSameBirthDay(num int) bool{
	brithDays := make(map[int]int)
	for i:=0;i&amp;lt;num;i++{
		day := generateBirth()
		brithDays[day]++
		if(brithDays[day] &amp;gt;1){
			return true
		}
	}
	return false
}

func main(){
	personNum := 50
	loopNum := 10000
	sameNum := 0
	for i:=0;i&amp;lt;loopNum;i++{
		if true == checkSameBirthDay(personNum){
			sameNum++
		}
	}
	fmt.Printf(&quot;The probability of same birthday in %d persons is %f\n&quot;,personNum,float64(sameNum)/float64(loopNum))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当人数为50人，结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go run birthday.go
The probability of same birthday in 50 persons is 0.973000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与计算的值相差无几。&lt;/p&gt;
&lt;h1 id=&quot;四参考链接&quot;&gt;四、参考链接&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html&quot;&gt;贝叶斯推断及其互联网应用（一）：定理简介&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html&quot;&gt;哈希碰撞与生日攻击&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%94%9F%E6%97%A5%E5%95%8F%E9%A1%8C&quot;&gt;维基百科：生日问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/PbGc396Dwxjb77F2je/article/details/78786980&quot;&gt;
朴素贝叶斯案例2：拼写纠错（python实现）&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Git webhook 实现自动部署教程</title>
   <link href="http://spetacular.github.io/2017/10/31/git-webhooks-for-php.html"/>
   <updated>2017-10-31T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/10/31/git-webhooks-for-php</id>
   <content type="html">&lt;p&gt;Git Hook(钩子) 是 Git 在代码提交、推送、合并等工作流程中引入的事件触发器，其中最常用的场景是代码检查，持续集成，自动部署等。本文主要讲解一下利用 Git webhook 实现自动部署。&lt;/p&gt;

&lt;h1 id=&quot;一git-hook&quot;&gt;一、Git hook&lt;/h1&gt;

&lt;p&gt;Git 的 hook 分为本地仓库 hook 和服务器仓库 hook。&lt;/p&gt;

&lt;h2 id=&quot;本地-hook&quot;&gt;本地 hook&lt;/h2&gt;

&lt;p&gt;本地 hook 通常在代码的 .git/hooks 目录下，如下所示：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;hooks git:&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;master&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ls
applypatch-msg.sample     pre-commit.sample         prepare-commit-msg.sample
commit-msg.sample         update.sample
post-update.sample        pre-push.sample
pre-applypatch.sample     pre-rebase.sample
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认情况下，这些脚本不会生效。使用时，只需将 &lt;code class=&quot;highlighter-rouge&quot;&gt;.sample&lt;/code&gt; 后缀去掉，然后赋予脚本执行权限即可。&lt;/p&gt;

&lt;p&gt;本地 hook 主要用于代码静态分析、REVIEW、代码规范、命名规范等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;pre-commit&lt;/p&gt;

    &lt;p&gt;提交之前的代码检查，包括是否通过单元测试，静态代码分析&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prepare-commit-msg&lt;/p&gt;

    &lt;p&gt;提交信息之前，可用来生成默认的提交信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;commit-msg&lt;/p&gt;

    &lt;p&gt;提交信息之后，可用来检查提交信息是否符合特定的格式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;post-commit&lt;/p&gt;

    &lt;p&gt;提交代码之后，一般用来通知代码已提交。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;post-checkout&lt;/p&gt;

    &lt;p&gt;checkout 代码之后，可用来设置工作目录、生成文档、生成静态资源等工作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;post-merge&lt;/p&gt;

    &lt;p&gt;合并代码之后，可用来保存 merge 操作中，git 没有保存的信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pre-push&lt;/p&gt;

    &lt;p&gt;push 代码之前，可用来检查本次 push 的 commits 是否符合特定的标准。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;服务器-hook&quot;&gt;服务器 hook&lt;/h2&gt;

&lt;p&gt;服务器 hook 指代码传输到服务器时，在服务器端所做的一系列操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;pre-receive&lt;/p&gt;

    &lt;p&gt;处理 push 操作之前，可以检查本次 push 的 commits 和文件是否符合特定的标准。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;update&lt;/p&gt;

    &lt;p&gt;update 与 pre-receive 操作类似，不同的是 pre-receive 只执行一次，而 update 可能执行多次。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;post-receive&lt;/p&gt;

    &lt;p&gt;整个提交过程完成之后，可用于更新其它服务或通知用户，比如发邮件告诉开发人员已提交代码，通知持续集成 (Continuous Integration) 服务器部署代码&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;webhook&quot;&gt;webhook&lt;/h2&gt;

&lt;p&gt;如果 Git 服务部署在自己的服务器上，如用 &lt;a href=&quot;https://about.gitlab.com/&quot;&gt;GitLab&lt;/a&gt; 搭建一套 Git 服务，则可以使用服务器 hook。如果使用了 &lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;、&lt;a href=&quot;https://bitbucket.org/&quot;&gt;Bitbucket&lt;/a&gt; 等云端平台，那么只能使用 webhook 来完成脚本。&lt;/p&gt;

&lt;p&gt;webhook 本质上属于服务器 hook，因为发送通知的方式是网络请求，因此得名。使用 webhook 的步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设置用于接收请求的 URL。&lt;/li&gt;
  &lt;li&gt;服务器收到 push、pull request、merge、tag 等操作时，会将相应信息发送给步骤 1 里的 URL。&lt;/li&gt;
  &lt;li&gt;URL 对应的程序收到网络请求后，执行自动部署、邮件通知等操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;二部署-webhook&quot;&gt;二、部署 webhook&lt;/h1&gt;

&lt;h2 id=&quot;环境假设&quot;&gt;环境假设&lt;/h2&gt;

&lt;p&gt;为叙述方便，我们做如下假设。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;项目&lt;/th&gt;
      &lt;th&gt;值&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;域名&lt;/td&gt;
      &lt;td&gt;www.weixinbook.net&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;接收请求的URL&lt;/td&gt;
      &lt;td&gt;https://www.weixinbook.net/webhook.php&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;项目部署目录&lt;/td&gt;
      &lt;td&gt;/var/www/weixinbook&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;build.sh路径&lt;/td&gt;
      &lt;td&gt;/var/www/hooks/build.sh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;webhook.php&lt;/td&gt;
      &lt;td&gt;/var/www/weixinbook/webhook.php&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;环境&lt;/td&gt;
      &lt;td&gt;nginx php&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;用户组&lt;/td&gt;
      &lt;td&gt;www-data&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;git-项目地址&quot;&gt;Git 项目地址&lt;/h2&gt;

&lt;p&gt;Git 项目需要使用 SSH 地址，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;git@github.com:xxx/xxx.git&lt;/code&gt; 。如果之前采用了 HTTPS 链接，需要修改 .git/config 文件里的 url 字段：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi .git/config

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote &lt;span class=&quot;s2&quot;&gt;&quot;origin&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    url &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; git@github.com:xxx/xxx.git
    fetch &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; +refs/heads/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;:refs/remotes/origin/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;部署-ssh-无密码登录&quot;&gt;部署 SSH 无密码登录&lt;/h2&gt;

&lt;p&gt;首先需要生成 SSH key。&lt;/p&gt;

&lt;p&gt;如果使用 nginx:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo  -u www-data ssh-keygen -t rsa -C &lt;span class=&quot;s2&quot;&gt;&quot;nginx&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果使用 apache:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u apache ssh-keygen -t rsa -C &lt;span class=&quot;s2&quot;&gt;&quot;apache&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后复制你的 public key，粘贴到项目的“SSH 公钥”设置里。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以 GitHub 为例，在 Settings -&amp;gt; Deploy keys，选择 Add deploy key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/github_deploy_keys.png&quot; alt=&quot;GitHub Deploy Keys&quot; /&gt;&lt;/p&gt;

&lt;p&gt;添加完毕后，可以运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -T git@github.com&lt;/code&gt; 来验证是否设置成功。首次运行时会看到一条 RSA key 指纹的连接确认信息，输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;yes&lt;/code&gt; 回车即可。&lt;/p&gt;

&lt;p&gt;如果看到下面的信息，就说明设置生效了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-reStructuredText&quot;&gt;Hi username! You've successfully authenticated, but GitHub does not
provide shell access.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;webhookphp&quot;&gt;webhook.php&lt;/h2&gt;
&lt;p&gt;webhook.php 用来接收 webhook 请求，一般要做以下操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;监测请求来源合法性。检查方法：密码，AES等。&lt;/li&gt;
  &lt;li&gt;检查是否为特定分支，如 master 分支。&lt;/li&gt;
  &lt;li&gt;启动自动部署脚本，如完成拉取最新代码，重新设置目录权限等。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$raw_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file_get_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;php://input&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$pay_load&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;json_decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$raw_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//监测请求来源合法性，
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$pay_load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'password'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'pass'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ok 400'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//检查是否为master分支
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$pay_load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ref&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;refs/heads/master&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ok 401'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'sh /var/www/hooks/build.sh'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;buildsh&quot;&gt;build.sh&lt;/h2&gt;
&lt;p&gt;build.sh 用来执行自动部署的具体操作。一般情况下，不要放在外网可访问的 webroot 目录下。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#! /bin/bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SITE_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/var/www/weixinbook'&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'www-data'&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;USERGROUP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'www-data'&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$SITE_PATH&lt;/span&gt;
git reset --hard origin/master
git clean -f
git pull
git checkout master
chown -R &lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;:&lt;span class=&quot;nv&quot;&gt;$USERGROUP&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$SITE_PATH&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样每次在客户端 push 代码，服务器会发请求给 webhook.php，webhook.php 检查通过后，启动 build.sh 进行自动部署。&lt;/p&gt;

&lt;h1 id=&quot;三结语&quot;&gt;三、结语&lt;/h1&gt;

&lt;p&gt;自动部署并不难，如果失败，大部分是权限问题。解决的方法很简单：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;保证 ssh key 的用户为 www-data&lt;/li&gt;
  &lt;li&gt;保证 build.sh , webhook.php 以及代码目录的用户为 www-data.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;权限问题解决不了，不要草率地全用 root，这样会带来一定的安全风险。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Phabricator 入门教程</title>
   <link href="http://spetacular.github.io/2017/10/19/phabricator-install-and-config.html"/>
   <updated>2017-10-19T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/10/19/phabricator-install-and-config</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://phacility.com/phabricator/&quot;&gt;Phabricator&lt;/a&gt; 是一款用于敏捷开发的项目管理软件，它集成了众多实用功能，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代码管理：添加 Git, Mercurial 和 SVN 仓库，查看源码，review 代码&lt;/li&gt;
  &lt;li&gt;bug 追踪：测试人员、开发人员协同工作&lt;/li&gt;
  &lt;li&gt;项目管理：项目的启动、进展、完成&lt;/li&gt;
  &lt;li&gt;工作板：所有任务一目了然&lt;/li&gt;
  &lt;li&gt;wiki：构建文档&lt;/li&gt;
  &lt;li&gt;任务系统：创建任务、指派任务、完成任务、增加或降低优先级&lt;/li&gt;
  &lt;li&gt;博客系统：甚至可以写博客&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/phabricator_intro.png&quot; alt=&quot;phabricator介绍&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里介绍如何从零开始，完成 Phabricator 的安装配置，设置数据库和发送邮件配置，仅供参考。&lt;/p&gt;

&lt;h1 id=&quot;前提条件&quot;&gt;前提条件&lt;/h1&gt;

&lt;p&gt;Phabricator 的运行环境是 php，数据库采用 mysql，web服务器可选 nginx、apache、lighttpd等。&lt;/p&gt;

&lt;p&gt;如果操作系统为 ubuntu ，希望快速安装，可以拷贝 &lt;a href=&quot;https://secure.phabricator.com/source/phabricator/browse/master/scripts/install/install_ubuntu.sh&quot;&gt;install_ubuntu.sh&lt;/a&gt; 脚本，一键安装 php5、apache、mysql-server。&lt;/p&gt;

&lt;p&gt;这里安装 php5 (包括所需扩展)、nginx、mysql-server。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install php5 php5-mysql php5-gd php5-dev php5-curl php-apc php5-cli php5-json nginx mysql-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;tipsphp-7-的兼容性&quot;&gt;Tips：PHP 7 的兼容性&lt;/h2&gt;

&lt;p&gt;如果你的环境是PHP 7.0，那么恭喜你，Phabricator 无法运行在 PHP 7.0 下。&lt;/p&gt;

&lt;p&gt;Phabricator 支持 5.x 版本以及 7.1 以上版本，唯独不支持 7.0。&lt;/p&gt;

&lt;p&gt;据&lt;a href=&quot;https://secure.phabricator.com/T12101&quot;&gt;官方声明&lt;/a&gt;，Phabricator 依赖的异步信号处理特性，在 7.0 版本被移除了，但是在7.1 版本又加上了。&lt;/p&gt;

&lt;p&gt;使用 PHP 7.0 的用户，可以降级到 PHP 5 或升级到 PHP 7.1，或者用 Docker。&lt;/p&gt;

&lt;h1 id=&quot;安装&quot;&gt;安装&lt;/h1&gt;

&lt;p&gt;Phabricator 需要 3 个仓库的代码：arcanist、libphutil、phabricator。其中phabricator是项目的主体，arcanist 是 Phabricator 的命令行工具，libphutil 是Phabricator 的实用工具集，包括文件系统、markdown解析、守护进程等。&lt;/p&gt;

&lt;p&gt;假设 &lt;code class=&quot;highlighter-rouge&quot;&gt;webroot&lt;/code&gt; 目录为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/www&lt;/code&gt;，则执行如下命令：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /var/www
mkdir phabricator &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$_&lt;/span&gt;
git clone https://github.com/phacility/libphutil.git
git clone https://github.com/phacility/arcanist.git
git clone https://github.com/phacility/phabricator.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;保证 arcanist、libphutil、phabricator 目录为并列关系。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;root@localhost:/var/www/phabricator# &lt;/span&gt;ls
arcanist  libphutil  phabricator
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;配置 nginx：&lt;/p&gt;

&lt;p&gt;其中 root 指向 phabricator 目录的 webroot。&lt;/p&gt;

&lt;div class=&quot;language-nginx highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kn&quot;&gt;server_name&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;phabricator.example.com&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kn&quot;&gt;root&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;/var/www/phabricator/phabricator/webroot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kn&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;index.php&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;rewrite&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;^/(.*)&lt;/span&gt;$ &lt;span class=&quot;n&quot;&gt;/index.php?__path__=/&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kn&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;/index.php&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;fastcgi_pass&lt;/span&gt;   &lt;span class=&quot;nf&quot;&gt;localhost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;fastcgi_index&lt;/span&gt;   &lt;span class=&quot;s&quot;&gt;index.php&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;#required if PHP was built with --enable-force-cgi-redirect
&lt;/span&gt;    &lt;span class=&quot;kn&quot;&gt;fastcgi_param&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;REDIRECT_STATUS&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;#variables to make the $_SERVER populate in PHP
&lt;/span&gt;    &lt;span class=&quot;kn&quot;&gt;fastcgi_param&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;SCRIPT_FILENAME&lt;/span&gt;    &lt;span class=&quot;nv&quot;&gt;$document_root$fastcgi_script_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;fastcgi_param&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;QUERY_STRING&lt;/span&gt;       &lt;span class=&quot;nv&quot;&gt;$query_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;fastcgi_param&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;REQUEST_METHOD&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;$request_method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;fastcgi_param&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;CONTENT_TYPE&lt;/span&gt;       &lt;span class=&quot;nv&quot;&gt;$content_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;fastcgi_param&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;CONTENT_LENGTH&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;$content_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kn&quot;&gt;fastcgi_param&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;SCRIPT_NAME&lt;/span&gt;        &lt;span class=&quot;nv&quot;&gt;$fastcgi_script_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kn&quot;&gt;fastcgi_param&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;GATEWAY_INTERFACE&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;CGI/1.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;fastcgi_param&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;SERVER_SOFTWARE&lt;/span&gt;    &lt;span class=&quot;s&quot;&gt;nginx/&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$nginx_version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kn&quot;&gt;fastcgi_param&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;REMOTE_ADDR&lt;/span&gt;        &lt;span class=&quot;nv&quot;&gt;$remote_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;配置&quot;&gt;配置&lt;/h1&gt;

&lt;h2 id=&quot;数据库&quot;&gt;数据库&lt;/h2&gt;

&lt;p&gt;首先要设置用于 Phabricator 连接的数据库配置。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /var/www/phabricator/phabricator
phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/config &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;mysql.host localhost
phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/config &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;mysql.user root
phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/config &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;mysql.pass 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后执行：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/storage upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;邮件&quot;&gt;邮件&lt;/h2&gt;

&lt;p&gt;Phabricator 支持的&lt;a href=&quot;https://secure.phabricator.com/book/phabricator/article/configuring_outbound_email/&quot;&gt;邮件系统&lt;/a&gt;很多，如Mailgun、Amazon SES、SendGrid、SMTP。这里以 SMTP 为例。&lt;/p&gt;

&lt;p&gt;有两种方式配置邮件发送。&lt;/p&gt;

&lt;h3 id=&quot;1-配置文件&quot;&gt;1. 配置文件&lt;/h3&gt;

&lt;p&gt;修改 conf/local/local.json ，加入如下配置：&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;phpmailer.smtp-protocol&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;SSL&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;phpmailer.smtp-password&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;密码&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;phpmailer.smtp-user&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;邮箱地址&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;phpmailer.smtp-port&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;端口号&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;phpmailer.smtp-host&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;邮件服务器&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2-命令行&quot;&gt;2. 命令行&lt;/h3&gt;

&lt;p&gt;用 bin/config 命令进行设置，如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/config &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;phpmailer.smtp-protocol ssl
phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/config &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;phpmailer.smtp-password 密码
phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/config &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;phpmailer.smtp-user 邮箱地址
phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/config &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;phpmailer.smtp-port 端口号
phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/config &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;phpmailer.smtp-host 邮件服务器
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;

&lt;p&gt;配置完成后，可以用命令行测试邮件发送配置是否正确：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/mail list-outbound   &lt;span class=&quot;c&quot;&gt;# 列出所有邮件&lt;/span&gt;
phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/mail show-outbound   &lt;span class=&quot;c&quot;&gt;# 显示某条邮件&lt;/span&gt;
phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/mail send-test       &lt;span class=&quot;c&quot;&gt;# 发送测试邮件&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如给 david 发送 主题为 hello 的邮件，正文在 body.txt 里：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/mail send-test --to david --subject &lt;span class=&quot;s1&quot;&gt;'hello'&lt;/span&gt; &amp;lt; ./body.txt
Reading message body from stdin...
Mail sent! You can view details by running this &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt;:

    phabricator/ &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./bin/mail show-outbound --id 37773
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;./bin/mail show-outbound --id 37773&lt;/code&gt; 可以看到此处发送的调试信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PROPERTIES
ID: 37773
Status: sent
Related PHID:
Message:

PARAMETERS
sensitive: 1
cc: []
subject: hello
is-bulk:
mailtags: []
...............
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这些命令对调试邮件配置和开发新的邮件适配器 (Adapter) 很有用处。&lt;/p&gt;

&lt;p&gt;#结语&lt;/p&gt;

&lt;p&gt;至此，Phabricator 可以使用了。更详细的功能和配置请参考  &lt;a href=&quot;https://secure.phabricator.com/book/phabricator/&quot;&gt;Phabricator User Documentation&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MySQL 1045 Access denied 和 1449 The user specified as a definer does not exist 错误处理</title>
   <link href="http://spetacular.github.io/2017/05/31/mysql-1045-access-denied-view-definer.html"/>
   <updated>2017-05-31T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/05/31/mysql-1045-access-denied-view-definer</id>
   <content type="html">&lt;p&gt;MySQL 使用新建用户查询时，如果数据库中有 view，可能会出现这样的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;SQLSTATE[28000]: Invalid authorization specification: 1045 Access denied for user 'user'@'10.174.68.21' (using password: YES)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;SQLSTATE[HY000]: General error: 1449 The user specified as a definer ('db_prod'@'%') does not exist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其表现是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;涉及到 table 的查询都正常；&lt;/li&gt;
  &lt;li&gt;涉及到 view 的查询都报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大多数情况下，出现此问题的根源是view definer设置不当。&lt;/p&gt;

&lt;h1 id=&quot;查看所有的-definer&quot;&gt;查看所有的 definer&lt;/h1&gt;

&lt;p&gt;可以先检查下所有 view 的 definer。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;select DEFINER from information_schema.VIEWS;                                          +---------------------------+
| DEFINER                   |
+---------------------------+
| db_prod@%                 |
| db_prod@%                 |
| db_prod@10.174.68.21      |
| root@127.0.0.1            |
+---------------------------+
4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现，某些 view 的 definer 为db_prod@% 。&lt;/p&gt;

&lt;h1 id=&quot;查看view的definer&quot;&gt;查看view的definer&lt;/h1&gt;

&lt;p&gt;进而可以查看单个 view 的 definer。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;SHOW CREATE VIEW viewname
CREATE ALGORITHM=UNDEFINED DEFINER=`db_prod`@`%` SQL SECURITY DEFINER VIEW `viewname` AS select * from tablename;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;创建用户时需要注意的事项&quot;&gt;创建用户时需要注意的事项&lt;/h1&gt;

&lt;p&gt;如果 view 的 definer 与当前的用户不一致，可以修改或删除用户。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;删除用户
DROP USER 'db_prod'@'10.174.68.21';
修改 definer
UPDATE `mysql`.`proc` p SET definer = 'root@localhost' WHERE definer='root@foobar' AND db='dbname';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在创建用户时，可以用如下 SQL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;创建用户
CREATE USER 'db_prod'@'%' IDENTIFIED BY '123456';
授权
GRANT ALL ON dbname.* TO 'db_prod'@'%';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键是保持 DEFINER 和创建用户时的用户名完全一致。&lt;/p&gt;

&lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/35662051/mysql-some-queries-produce-sqlstate28000-invalid-authorization-specificatio&quot;&gt;MySql: Some queries produce: SQLSTATE28000: Invalid authorization specification: 1045 Access denied for user&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zejin2008/p/4767531.html&quot;&gt;mysql如何修改所有的definer&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>PHP从数组中删除元素的四种方法</title>
   <link href="http://spetacular.github.io/2017/05/12/delete-element-from-array-php.html"/>
   <updated>2017-05-12T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/05/12/delete-element-from-array-php</id>
   <content type="html">&lt;p&gt;茴香豆的“茴”字有四种写法，PHP从数组中删除元素也有四种方法 ^_^。&lt;/p&gt;

&lt;h1 id=&quot;删除一个元素且保持原有索引不变&quot;&gt;删除一个元素，且保持原有索引不变&lt;/h1&gt;
&lt;p&gt;使用 &lt;a href=&quot;https://secure.php.net/manual/zh/function.unset.php&quot;&gt;unset&lt;/a&gt; 函数，示例如下：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;unset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
               &lt;span class=&quot;c1&quot;&gt;//↑ 你想删除的key
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Array (
    [0] =&amp;gt; a
    [2] =&amp;gt; c
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;unset&lt;/code&gt; 并未改变数组的原有索引。如果打算重排索引（让索引从0开始，并且连续），可以使用 &lt;a href=&quot;http://php.net/manual/zh/function.array-values.php&quot;&gt;array_values&lt;/a&gt; 函数：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$array = array_values($array);
/*
输出
array(2) {
  [0]=&amp;gt;
  string(1) &quot;a&quot;
  [1]=&amp;gt;
  string(1) &quot;c&quot;
}
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;删除一个元素不保持索引&quot;&gt;删除一个元素，不保持索引&lt;/h1&gt;

&lt;p&gt;使用 &lt;a href=&quot;http://php.net/manual/zh/function.array-splice.php&quot;&gt;array_splice&lt;/a&gt; 函数，示例如下：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;array_splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                       &lt;span class=&quot;c1&quot;&gt;//↑ 你想删除的元素的Offset
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Array (
    [0] =&amp;gt; a
    [1] =&amp;gt; c
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;按值删除多个元素保持索引&quot;&gt;按值删除多个元素，保持索引&lt;/h1&gt;

&lt;p&gt;使用 &lt;a href=&quot;http://php.net/manual/zh/function.array-diff.php&quot;&gt;array_diff&lt;/a&gt; 函数，示例如下：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;array_diff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
                              &lt;span class=&quot;c1&quot;&gt;//└────────┘→ 你想删除的数组元素值values
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Array (
    [1] =&amp;gt; b
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;unset&lt;/code&gt; 类似，&lt;code class=&quot;highlighter-rouge&quot;&gt;array_diff&lt;/code&gt; 也将保持索引。&lt;/p&gt;

&lt;h1 id=&quot;按键删除多个元素保持索引&quot;&gt;按键删除多个元素，保持索引&lt;/h1&gt;

&lt;p&gt;使用 &lt;a href=&quot;http://php.net/manual/zh/function.array-diff-key.php&quot;&gt;array_diff_key&lt;/a&gt; 函数，示例如下：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;

    &lt;span class=&quot;nv&quot;&gt;$array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;$array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;array_diff_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;xy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;xy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
                                   &lt;span class=&quot;c1&quot;&gt;//↑           ↑ 你想删除的数组键keys
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;language-php highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Array (
    [1] =&amp;gt; b
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;unset&lt;/code&gt; 类似，&lt;code class=&quot;highlighter-rouge&quot;&gt;array_diff_key&lt;/code&gt; 也将保持索引。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Postman 及 Newman 使用开发指南（六）：利用 Newman 进行冒烟测试</title>
   <link href="http://spetacular.github.io/2017/04/27/postman-use-newman-for-smoking-test.html"/>
   <updated>2017-04-27T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/04/27/postman-use-newman-for-smoking-test</id>
   <content type="html">&lt;p&gt;大家提到“冒烟测试”，大部分人会援引&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/ms182613(v=vs.90).aspx&quot;&gt;微软的定义&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在软件中，“冒烟测试”这一术语描述的是在将代码更改签入到产品的源树中之前对这些更改进行验证的过程。在检查了代码后，冒烟测试是确定和修复软件缺陷的最经济有效的方法。冒烟测试设计用于确认代码中的更改会按预期运行，且不会破坏整个版本的稳定性。&lt;/p&gt;

  &lt;p&gt;“冒烟测试”这一术语源自硬件行业。该术语源于此做法：对一个硬件或硬件组件进行更改或修复后，直接给设备加电。如果没有冒烟，则该组件就通过了测试。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于 API 接口来说，冒烟测试就是跑一遍测试，看看所有的返回结果是否符合预期。判断一次冒烟测试是否通过的标准，可以简化一下两条：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网络请求正常&lt;/li&gt;
  &lt;li&gt;返回内容符合预期&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本节我们用 Newman 编写冒烟测试案例，并生成自定义报表，附带邮件发送功能。本节的例子完整代码参考 &lt;a href=&quot;https://github.com/spetacular/newman-smoking-test&quot;&gt;https://github.com/spetacular/newman-smoking-test&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;nodejs-脚本&quot;&gt;nodejs 脚本&lt;/h1&gt;

&lt;p&gt;脚本用到了两个插件：&lt;a href=&quot;https://github.com/postmanlabs/newman&quot;&gt;Newman&lt;/a&gt; 和 &lt;a href=&quot;https://nodemailer.com/&quot;&gt;Nodemailer&lt;/a&gt; 。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install newman --save
npm install nodemailer --save
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;脚本 smoke.js:&lt;/p&gt;

&lt;p&gt;将 &lt;code class=&quot;highlighter-rouge&quot;&gt;---&lt;/code&gt; 包含的部分换成正确的配置即可。
&lt;script src=&quot;https://gist.github.com/spetacular/4e60770ebecda84064aacb123531b670.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&quot;自定义-html-模板&quot;&gt;自定义 HTML 模板&lt;/h1&gt;

&lt;p&gt;由于大部分邮件客户端只支持 inline 的 CSS 样式，所以我们将样式写到元素里。&lt;/p&gt;

&lt;p&gt;template.hbs 文件：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/spetacular/8b9375c373b8339cb2904cbcd56cffaa.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;最后发送邮件的效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_newman_mail.jpeg&quot; alt=&quot;newman冒烟测试效果&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完整代码参考 &lt;a href=&quot;https://github.com/spetacular/newman-smoking-test&quot;&gt;https://github.com/spetacular/newman-smoking-test&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Postman 及 Newman 使用开发指南（五）：Newman 简介</title>
   <link href="http://spetacular.github.io/2017/04/25/newman-develop-tutorial.html"/>
   <updated>2017-04-25T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/04/25/newman-develop-tutorial</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/newman&quot;&gt;Newman&lt;/a&gt; 是 Postman 推出的一个 nodejs 库。利用 Newman，我们可以很方便地运行和测试集合，并用之构造自动化测试和持续集成。&lt;/p&gt;

&lt;h1 id=&quot;安装运行&quot;&gt;安装运行&lt;/h1&gt;

&lt;p&gt;可以使用 npm 来 newman。如果还未安装 npm，可以 &lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;点此安装&lt;/a&gt; 。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install newman --global;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上一节中，我们将 Echo 集合导出，命名为 postman_echo.postman_collection.json。&lt;/p&gt;

&lt;p&gt;在命令行运行如下命令即可，即可启动测试。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;newman run postman_echo.postman_collection.json
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行界面如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_newman_run.gif&quot; alt=&quot;newman run动画&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;编程实现&quot;&gt;编程实现&lt;/h1&gt;

&lt;p&gt;新建文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;test_echo.js&lt;/code&gt;，内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var newman = require('newman'); // require newman in your project

// call newman.run to pass `options` object and wait for callback
newman.run({
    collection: require('./postman_echo.postman_collection.json'),
    reporters: 'cli'
}, function (err) {
	if (err) { throw err; }
    console.log('collection run complete!');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在命令行运行如下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node test_echo.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行效果和直接运行 newman 完全一致。&lt;/p&gt;

&lt;h1 id=&quot;结果导出方式&quot;&gt;结果导出方式&lt;/h1&gt;

&lt;p&gt;Postman 提供了5种导出方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cli：命令行&lt;/li&gt;
  &lt;li&gt;html：网页&lt;/li&gt;
  &lt;li&gt;json&lt;/li&gt;
  &lt;li&gt;junit：以 xml 格式导出&lt;/li&gt;
  &lt;li&gt;teamcity：导出到持续集成（Continuous Integration）工具 &lt;a href=&quot;https://www.jetbrains.com/teamcity/&quot;&gt;TeamCity&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外 Postman 的 html 导出方式支持自定义导出模板。如果不指定模板，将采用 &lt;a href=&quot;https://github.com/postmanlabs/newman/blob/develop/lib/reporters/html/template-default.hbs&quot;&gt;默认模板&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;api参考&quot;&gt;API参考&lt;/h1&gt;

&lt;p&gt;Newman 的核心方法是 &lt;code class=&quot;highlighter-rouge&quot;&gt;newman.run(options: *object* , callback: *function*) =&amp;gt; run: EventEmitter&lt;/code&gt;。其中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;options 为Newman运行时的设置项。&lt;/li&gt;
  &lt;li&gt;callback 为回调函数，会回传 error 和 summary 信息。&lt;/li&gt;
  &lt;li&gt;run 为函数主体，可监听事件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;options-设置项&quot;&gt;options 设置项&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;是否必需&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;类型&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;options&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;object&lt;/td&gt;
      &lt;td&gt;包含 run 一个集合所需的所有信息。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.collection&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;object|string|&lt;a href=&quot;https://github.com/postmanlabs/postman-collection/wiki#Collection&quot;&gt;PostmanCollection&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;指定 collection。可以传递collection 对象，也可以传递 URL 或本地  JSON 文件路径。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.environment&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;object|string&lt;/td&gt;
      &lt;td&gt;指定环境变量。可以传递“键=&amp;gt;值“对的对象，也可以传递 URL 或本地文件路径。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.globals&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;object|string&lt;/td&gt;
      &lt;td&gt;指定全局变量。可以传递对象，URL 或本地文件路径。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.iterationCount&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;number，默认值为1&lt;/td&gt;
      &lt;td&gt;指定循环的次数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.iterationData&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;string&lt;/td&gt;
      &lt;td&gt;当循环多次时，指定作为数据源的 JSON、CSV、URL的路径。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.folder&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;string&lt;/td&gt;
      &lt;td&gt;集合中文件夹的名称或 ID。设置此项后，只有该文件夹才会执行。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.timeoutRequest&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;number，默认值无穷大&lt;/td&gt;
      &lt;td&gt;请求超时时间，以毫秒为单位。默认不超时。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.delayRequest&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;number，默认值为 0&lt;/td&gt;
      &lt;td&gt;请求之间的时间间隔，以毫秒为单位。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.ignoreRedirects&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;boolean，默认值为 false&lt;/td&gt;
      &lt;td&gt;是否允许 3xx 跳转。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.insecure&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;boolean，默认值为 false&lt;/td&gt;
      &lt;td&gt;是否禁止 SSL 验证和允许自签名证书。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.bail&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;boolean，默认值为 false&lt;/td&gt;
      &lt;td&gt;遇到错误时是否终止运行。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.suppressExitCode&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;boolean，默认值为 false&lt;/td&gt;
      &lt;td&gt;是否覆盖退出码（Exit Code）。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.reporters&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;string|array&lt;/td&gt;
      &lt;td&gt;指定 reporter。可选 cli、json、html 和 junit。指定一种report时，用 string 即可，如  &lt;code class=&quot;highlighter-rouge&quot;&gt;cli&lt;/code&gt;；指定多种时，用array，如&lt;code class=&quot;highlighter-rouge&quot;&gt;['cli','html']。&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.reporter&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;object&lt;/td&gt;
      &lt;td&gt;指定特定 reporter 的属性。例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;reporter : { junit : { export : './xmlResults.xml' } }&lt;/code&gt; 或&lt;code class=&quot;highlighter-rouge&quot;&gt; reporter : { html : { export : './htmlResults.html', template: './customTemplate.hbs' } }&lt;/code&gt;。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.color&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;boolean&lt;/td&gt;
      &lt;td&gt;强制在 CLI 里使用彩色输出。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.noColor&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;boolean&lt;/td&gt;
      &lt;td&gt;强制在 CLI 里禁止彩色输出。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.sslClientCert&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;string&lt;/td&gt;
      &lt;td&gt;public client certificate file 路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.sslClientKey&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;string&lt;/td&gt;
      &lt;td&gt;private client key file 路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;options.sslClientPassphrase&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;string&lt;/td&gt;
      &lt;td&gt;secret client key passphrase&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;callback&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;function&lt;/td&gt;
      &lt;td&gt;run 完成之后，会调用 callback 函数，会回传 error 和 summary 信息。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;callback-回调&quot;&gt;callback 回调&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;error&lt;/td&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;致命错误信息，如 Newman 无法处理的异常。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;summary&lt;/td&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;本次 run 的所有汇总信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;summary.error&lt;/td&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;错误信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;summary.collection&lt;/td&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;集合信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;summary.environment&lt;/td&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;环境变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;summary.globals&lt;/td&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;全局变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;summary.run&lt;/td&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;本次 run 的信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;summary.run.stats&lt;/td&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;统计信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;summary.run.failures&lt;/td&gt;
      &lt;td&gt;array.&amp;lt;object&amp;gt;&lt;/td&gt;
      &lt;td&gt;失败信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;summary.run.executions&lt;/td&gt;
      &lt;td&gt;array.&amp;lt;object&amp;gt;&lt;/td&gt;
      &lt;td&gt;每个请求的信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;run-事件&quot;&gt;run 事件&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;事件&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;start&lt;/td&gt;
      &lt;td&gt;开始run collection&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;beforeIteration&lt;/td&gt;
      &lt;td&gt;一次循环开始之前&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;beforeItem&lt;/td&gt;
      &lt;td&gt;一个条目开始处理之前&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;beforePrerequest&lt;/td&gt;
      &lt;td&gt;pre-request 脚本开始执行之前&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;prerequest&lt;/td&gt;
      &lt;td&gt;pre-request 脚本执行完毕&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;beforeRequest&lt;/td&gt;
      &lt;td&gt;HTTP请求发送之前&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;request&lt;/td&gt;
      &lt;td&gt;HTTP响应接收之后&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;beforeTest&lt;/td&gt;
      &lt;td&gt;测试脚本执行之前&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;test&lt;/td&gt;
      &lt;td&gt;测试脚本执行之后&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;beforeScript&lt;/td&gt;
      &lt;td&gt;任意脚本（测试脚本或pre-request 脚本）开始执行之前&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;script&lt;/td&gt;
      &lt;td&gt;任意脚本（测试脚本或pre-request 脚本）执行之后&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;item&lt;/td&gt;
      &lt;td&gt;一个条目执行完毕之后&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iteration&lt;/td&gt;
      &lt;td&gt;一个循环执行完毕之后&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;assertion&lt;/td&gt;
      &lt;td&gt;测试脚本里每个测试用例被执行之后&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;console&lt;/td&gt;
      &lt;td&gt;console方法被调用时触发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;exception&lt;/td&gt;
      &lt;td&gt;脚本错误出现时触发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;beforeDone&lt;/td&gt;
      &lt;td&gt;run结束之前&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;done&lt;/td&gt;
      &lt;td&gt;run结束，无论有没有错误都触发&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;完整参考请查看 &lt;a href=&quot;https://github.com/postmanlabs/newman&quot;&gt;https://github.com/postmanlabs/newman&lt;/a&gt; 。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Postman 及 Newman 使用开发指南（四）：Postman Collection 与 Runner</title>
   <link href="http://spetacular.github.io/2017/04/23/postman-collection-and-runner.html"/>
   <updated>2017-04-23T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/04/23/postman-collection-and-runner</id>
   <content type="html">&lt;p&gt;在 Postman 里，集合（Collection）是一个很重要的概念，它可以将多个请求进行分组。在每个集合内部，又可向下细分为不同的文件夹。结构化的优点是利于后续查看和维护。&lt;/p&gt;

&lt;h1 id=&quot;集合-collection&quot;&gt;集合 Collection&lt;/h1&gt;

&lt;h2 id=&quot;创建&quot;&gt;创建&lt;/h2&gt;

&lt;p&gt;创建集合有两种方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在左边栏处点击新建。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_collection.jpeg&quot; alt=&quot;postman创建集合&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;保存或另存请求时，直接新建。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/2017/postman_collection_add.jpeg&quot; alt=&quot;postman创建集合&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;管理&quot;&gt;管理&lt;/h2&gt;

&lt;p&gt;点击每个集合右侧的“&amp;lt;”和“…”，会分别展开集合详情和集合操作页面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_collection_detail.jpeg&quot; alt=&quot;postman创建管理&quot; /&gt;&lt;/p&gt;

&lt;p&gt;集合详情介绍该集合的名称、简介（支持 Markdown 语法），并可分享、编辑、复制、导出、删除等。点击蓝色的 “Run” 按钮，会进入 Runner 页面。&lt;/p&gt;

&lt;p&gt;集合操作则列出对集合的常用操作：分享、重命名、编辑、新增文件夹、复制、导出、删除。Pro 版还有监控和发布文档功能。&lt;/p&gt;

&lt;h2 id=&quot;导出功能&quot;&gt;导出功能&lt;/h2&gt;

&lt;p&gt;导出功能是一个非常重要的功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_export.jpeg&quot; alt=&quot;postman集合导出&quot; /&gt;&lt;/p&gt;

&lt;p&gt;导出文件后，你可以分享给同事，在其它电脑上导入，而且可以在命令行中使用。推荐使用v2版本。&lt;/p&gt;

&lt;h1 id=&quot;runner&quot;&gt;Runner&lt;/h1&gt;

&lt;p&gt;Runner 是一个对集合中请求进行测试的工具。它会检测每个请求的测试用例，最终返回结果汇总和统计数据。&lt;/p&gt;

&lt;p&gt;有两种方式进入 Runner：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;集合详情页，点击蓝色的 “Run” 按钮。&lt;/li&gt;
  &lt;li&gt;Postman 左上角 “Runner” 按钮。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;进入后，可以选择一个集合，或集合中的某一文件夹进行测试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_runner_ui.jpeg&quot; alt=&quot;postman Runner&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 Start Run 之前，可以选择环境，确定循环次数，确定发送请求的时间间隔，日志保存选项，并可以上传相关的文件。&lt;/p&gt;

&lt;p&gt;点击 Start Run，Runner工具开始按照设置运行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_runner_running.jpeg&quot; alt=&quot;postman Runner正在运行&quot; /&gt;&lt;/p&gt;

&lt;p&gt;全部完成后，展示测试数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_runner_done.jpeg&quot; alt=&quot;postman runner 结果汇总&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在此页面，可以查看汇总信息，导出结果，重试该测试。&lt;/p&gt;

&lt;p&gt;Runner提供了批量测试的功能，Run 一下，就知道接口响应是否符合预期。更重要的是，Runner 可以在命令行运行，即可编程。借助此工具，我们就可以完成定时脚本、健康检测、冒烟测试等功能。下节，我将介绍 ”Run in Command Line“ 的工具：Newman 。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Postman 及 Newman 使用开发指南（三）：Postman Test 与接口测试</title>
   <link href="http://spetacular.github.io/2017/04/22/postman-api-test.html"/>
   <updated>2017-04-22T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/04/22/postman-api-test</id>
   <content type="html">&lt;p&gt;API 开发、测试、维护的过程中，我们希望接口各司其职，并且一贯如此。做到这一点，我们需要检查下列选项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网络连接是否正常&lt;/li&gt;
  &lt;li&gt;响应时间是否控制在1秒以下&lt;/li&gt;
  &lt;li&gt;HTTP 返回状态码是否为200&lt;/li&gt;
  &lt;li&gt;符合一定的JSON或XML格式&lt;/li&gt;
  &lt;li&gt;返回内容是否包含特定字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只有所有的选项都符合预期，我们才会认为接口正常工作。&lt;/p&gt;

&lt;p&gt;Postman Builder页面提供了接口测试的功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_tests.jpeg&quot; alt=&quot;单元测试&quot; /&gt;&lt;/p&gt;

&lt;p&gt;书写测试用例的方法是，在tests数组中增加一个元素，key为测试用例的名称，value为表达式。如果执行过后表达式的值为 true ，表明通过测试；反之，未通过测试。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tests[&quot;Body matches string&quot;] = responseBody.has(&quot;string_you_want_to_search&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Postman 常见的测试用例如下：&lt;/p&gt;

&lt;p&gt;设置环境变量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;postman.setEnvironmentVariable(&quot;key&quot;, &quot;value&quot;);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取环境变量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;postman.getEnvironmentVariable(&quot;key&quot;);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置全局变量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;postman.setGlobalVariable(&quot;key&quot;, &quot;value&quot;);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取全局变量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;postman.getGlobalVariable(&quot;key&quot;); 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;返回内容是否包含特定字符串&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tests[&quot;Body matches string&quot;] = responseBody.has(&quot;string_you_want_to_search&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将 XML 转化为 JSON&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var jsonObject = xml2Json(responseBody);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;返回内容是否为特定字符串&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tests[&quot;Body is correct&quot;] = responseBody === &quot;response_body_string&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检查 JSON 数据的某个字段是否等于特定值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var data = JSON.parse(responseBody);
tests[&quot;Your test name&quot;] = data.value === 100;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检查是否存在 Content-Type（区分大小写）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tests[&quot;Content-Type is present&quot;] = postman.getResponseHeader(&quot;Content-Type&quot;); //Note: the getResponseHeader() method returns the header value, if it exists.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检查是否存在 Content-Type（区分大小写）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tests[&quot;Content-Type is present&quot;] = responseHeaders.hasOwnProperty(&quot;Content-Type&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;响应时间小于 200ms&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tests[&quot;Response time is less than 200ms&quot;] = responseTime &amp;lt; 200;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;HTTP 返回状态码为 200&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tests[&quot;Status code is 200&quot;] = responseCode.code === 200;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;HTTP 返回状态码包含特定字符串&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tests[&quot;Status code name has string&quot;] = responseCode.name.has(&quot;Created&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;POST 请求成功的状态码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tests[&quot;Successful POST request&quot;] = responseCode.code === 201 || responseCode.code === 202;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;利用 TinyValidator 来检查 JSON 是否符合特定格式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var schema = {
 &quot;items&quot;: {
 &quot;type&quot;: &quot;boolean&quot;
 }
};
var data1 = [true, false];
var data2 = [true, 123];

tests[&quot;Valid Data1&quot;] = tv4.validate(data1, schema);
tests[&quot;Valid Data2&quot;] = tv4.validate(data2, schema);
console.log(&quot;Validation failed: &quot;, tv4.error);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该例子的样本文件如下：&lt;/p&gt;

&lt;p&gt;JSON 文件：&lt;a href=&quot;http://www.getpostman.com/samples/test_data_file.json&quot;&gt;Download JSON file&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CSV 文件：&lt;a href=&quot;http://www.getpostman.com/samples/test_data_file.csv&quot;&gt;Download CSV file&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Postman 及 Newman 使用开发指南（二）：Postman 环境变量与全局变量</title>
   <link href="http://spetacular.github.io/2017/04/21/postman-environment-variable-and-global-variable.html"/>
   <updated>2017-04-21T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/04/21/postman-environment-variable-and-global-variable</id>
   <content type="html">&lt;p&gt;使用API的常见场景是开发人员有自己的本机开发（dev）环境，团队之间共用测试（staging）环境，对外提供生产（production）环境。&lt;/p&gt;

&lt;p&gt;本文假设各种环境的链接如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dev http://localhost
staging http://staging
production https://production
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;开发人员对&lt;code class=&quot;highlighter-rouge&quot;&gt;/users&lt;/code&gt;接口进行调试时，如果没有环境变量，则可能要不断地输入以下链接进行替换：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-reStructuredText&quot;&gt;http://localhost/users
http://staging/users
https://production/users
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Postman 提供了环境变量（Environment Variable），来解决这个问题。&lt;/p&gt;

&lt;h1 id=&quot;环境变量&quot;&gt;环境变量&lt;/h1&gt;

&lt;h2 id=&quot;管理&quot;&gt;管理&lt;/h2&gt;

&lt;p&gt;Postman 环境变量相关按钮放置在Builder页面的右上角。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_env.jpeg&quot; alt=&quot;postman环境变量相关按钮&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击最右的 ⚙️ 图标，可以添加、编辑、查看环境。首先，我们添加一个staging的环境，下属变量url设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;http://staging&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_add_env.jpeg&quot; alt=&quot;postman环境变量相关按钮&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再添加dev和production环境。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_env_lists.jpeg&quot; alt=&quot;postman环境变量相关按钮&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;使用示例&quot;&gt;使用示例&lt;/h2&gt;

&lt;p&gt;我们将环境切换为&lt;code class=&quot;highlighter-rouge&quot;&gt;dev&lt;/code&gt;，在地址栏输入{{url}}/users，查看“Code”代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /users HTTP/1.1
Host: localhost
Cache-Control: no-cache
Postman-Token: 9a0ae49e-8983-55f2-7585-a4ea721863da
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可见，Postman 自动将{{url}}解析为&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;全局变量&quot;&gt;全局变量&lt;/h1&gt;

&lt;p&gt;API测试时，也常有这样的场景：首先要进行登录，登录后获取用户名，而用户名将在后续请求中使用。&lt;/p&gt;

&lt;p&gt;Postman 提供了全局变量（Global Variable），来解决类似问题。&lt;/p&gt;

&lt;h1 id=&quot;设置全局变量&quot;&gt;设置全局变量&lt;/h1&gt;

&lt;p&gt;至少有三种方式来设置全局变量：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Postman 全局变量的按钮放置在Builder页面的右上角，👁️ 图标。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_var.jpeg&quot; alt=&quot;postman全局变量相关按钮&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击“Global”对应的“Edit”即可进入管理页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_set_var.jpeg&quot; alt=&quot;postman全局变量相关按钮&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pre-request Script&lt;/li&gt;
  &lt;li&gt;Tests&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中方式2和方式3都可以用以下命令设置全局变量：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;postman&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setGlobalVariable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;variable_key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;variable_value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;示例&quot;&gt;示例&lt;/h1&gt;

&lt;p&gt;我们首先通过上节的方式1添加一个全局变量：&lt;code class=&quot;highlighter-rouge&quot;&gt;leap_year_2016&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_var_false.jpeg&quot; alt=&quot;postman全局变量&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们访问 Postman 官方示例中判断年份是否为闰年的链接：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://postman-echo.com/time/leap?timestamp=2016-10-10
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在Tests里添加如下代码：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;jsonData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;responseBody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;postman&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setGlobalVariable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'leap_year_2016'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;jsonData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;leap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_var_leap.jpeg&quot; alt=&quot;postman全局变量&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发送请求后，由于2016年是闰年，所以全局变量&lt;code class=&quot;highlighter-rouge&quot;&gt;leap_year_2016&lt;/code&gt;值应变为true。&lt;/p&gt;

&lt;p&gt;查看一下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_var_true.jpeg&quot; alt=&quot;postman全局变量&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;leap_year_2016=true&lt;/code&gt;，符合预期。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Postman 及 Newman 使用开发指南（一）：Postman 简介</title>
   <link href="http://spetacular.github.io/2017/04/20/postman-and-newman-development.html"/>
   <updated>2017-04-20T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/04/20/postman-and-newman-development</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;https://www.getpostman.com/&quot;&gt;Postman&lt;/a&gt; 是一款帮助开发者分享、测试、文档化、监控API接口的工具。它最开始是一个 &lt;a href=&quot;https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop&quot;&gt;Chrome插件&lt;/a&gt; ，但现在提供了 Mac、Windwos、Linux、Chrome 全平台的支持。&lt;/p&gt;

&lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;

&lt;h2 id=&quot;下载安装&quot;&gt;下载安装&lt;/h2&gt;

&lt;p&gt;Postman 目前提供了全平台的版本，读者可以到以下地址进行下载安装。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.getpostman.com/&quot;&gt;https://www.getpostman.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装启动后，界面如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_ui.jpeg&quot; alt=&quot;postman界面&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;界面介绍&quot;&gt;界面介绍&lt;/h2&gt;

&lt;h3 id=&quot;顶部&quot;&gt;顶部&lt;/h3&gt;

&lt;p&gt;Show/Hide Sidebar: 显示或隐藏边栏&lt;/p&gt;

&lt;p&gt;Runner: 打开接口测试工具Runner；&lt;/p&gt;

&lt;p&gt;Import: 导入postman数据，包括postman集合、环境变量、curl命令等文件；&lt;/p&gt;

&lt;p&gt;Open: 打开新窗口&lt;/p&gt;

&lt;p&gt;Builder: 请求构造器，为主工作区域&lt;/p&gt;

&lt;p&gt;Team Library：团队工作区域&lt;/p&gt;

&lt;p&gt;SYNC：同步功能，登录后可将本地数据集上传到云端，以便备份、分享或异处使用。&lt;/p&gt;

&lt;p&gt;Sign In：登录功能。&lt;/p&gt;

&lt;p&gt;设置：设置，文档，官方支持中心&lt;/p&gt;

&lt;h3 id=&quot;边栏&quot;&gt;边栏&lt;/h3&gt;

&lt;p&gt;Filter：搜索框，提供关键字检索&lt;/p&gt;

&lt;p&gt;History：请求历史，按时间倒序&lt;/p&gt;

&lt;p&gt;Collections：postman集合，包含多个API。这是一个很重要的概念，后续的Runner就是基于集合进行的。&lt;/p&gt;

&lt;h3 id=&quot;builder&quot;&gt;Builder&lt;/h3&gt;

&lt;p&gt;请求构造器，使用方式类似于浏览器。最简单的使用方式就是在地址栏输入地址，点击“Send”按钮，稍后响应窗口会显示响应结果。&lt;/p&gt;

&lt;p&gt;postman可指定如下请求构造部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;请求方式：GET、POST、PUT、PATCH、DELETE、COPY、HEAD、OPTIONS、LINK、UNLINK、PURGE、LOCK、UNLOCK、PROPFIND、VIEW&lt;/li&gt;
  &lt;li&gt;参数：支持可视化编辑、批量编辑&lt;/li&gt;
  &lt;li&gt;认证方式：Authorization方式，支持No Auth、Basic Auth、Digest Auth、OAuth 1.0、OAuth 2.0、Hawk Authentication、AWS Signature。其中No Auth是利用Cookie认证。&lt;/li&gt;
  &lt;li&gt;headers：设置请求头&lt;/li&gt;
  &lt;li&gt;Body：当请求为POST方式时，可以设置Body。共有四种情况：
    &lt;ul&gt;
      &lt;li&gt;form-data：模拟表单提交&lt;/li&gt;
      &lt;li&gt;x-www-form-urlencoded：模拟ajax请求&lt;/li&gt;
      &lt;li&gt;raw：原始格式，支持多种格式，包括Text、JSON、Javascript、XML、HTML等&lt;/li&gt;
      &lt;li&gt;binary：上传文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pre-request Script: 提交请求之前执行的脚本。&lt;/li&gt;
  &lt;li&gt;Tests：对响应结果做测试。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;postman可以查看响应结果：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Body： 响应内容，支持JSON、XML美化高亮方式。&lt;/li&gt;
  &lt;li&gt;Cookies：返回Cookies&lt;/li&gt;
  &lt;li&gt;Headers：响应头信息。&lt;/li&gt;
  &lt;li&gt;Tests：对响应结果的单元测试。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;功能&quot;&gt;功能&lt;/h1&gt;

&lt;h2 id=&quot;生成code&quot;&gt;生成Code&lt;/h2&gt;

&lt;p&gt;Builder页面的右上角，有“Cookie”、”Code“字样，点击”Code“，可以查看各种语言生成的请求代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_code.jpeg&quot; alt=&quot;生成code&quot; /&gt;&lt;/p&gt;

&lt;p&gt;目前支持大部分常用语言，包括HTTP、C、cURL、C#、Go、Java、Javascript、NodeJS、Object-C、OCaml、PHP、Python、Ruby、Shell、Swift等。&lt;/p&gt;

&lt;h2 id=&quot;管理cookie&quot;&gt;管理Cookie&lt;/h2&gt;

&lt;p&gt;Builder页面的右上角，有“Cookie”、”Code“字样，点击”Cookie“，可以进入管理Cookie页面。「注意：某些版本的postman还未集成此功能，如Chrome插件」&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_cookie.jpeg&quot; alt=&quot;管理Cookie&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;单元测试&quot;&gt;单元测试&lt;/h2&gt;

&lt;p&gt;请求一个接口后，我们可能希望这个接口能满足一定的条件，如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP返回码为200&lt;/li&gt;
  &lt;li&gt;符合一定的JSON格式&lt;/li&gt;
  &lt;li&gt;响应时间少于200ms&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;postman的tests功能可以满足此需求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/postman_tests.jpeg&quot; alt=&quot;单元测试&quot; /&gt;&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;tests&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Status code is 200&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;responseCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;jsonData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;responseBody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;tests&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2016 is a leap year&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;jsonData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;leap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们希望HTTP返回码为200。2016年是闰年，所以我们希望返回leap=true。&lt;/p&gt;

&lt;p&gt;而响应窗口的Tests选项卡，显示2条测试都通过，说明接口一切正常。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Nginx缓存最佳实践</title>
   <link href="http://spetacular.github.io/2017/04/10/nginx-cache.html"/>
   <updated>2017-04-10T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/04/10/nginx-cache</id>
   <content type="html">&lt;p&gt;与&lt;a href=&quot;https://varnish-cache.org/&quot;&gt;Varnish&lt;/a&gt;类似，&lt;a href=&quot;https://nginx.org/&quot;&gt;Nginx&lt;/a&gt;非常适合做网页缓存。许多管理员转向Varnish，因为Varnish确实有用。但是，Nginx也有如下优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nginx能非常有效地直接处理静态内容。在静态文件和Nginx在同一主机的情况下，这种特性尤为有用。&lt;/li&gt;
  &lt;li&gt;当放置在应用服务器前端时，Nginx确实能够担当缓存服务器的角色。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然Varnish作为网页缓存服务器拥有比Nginx更丰富的缓存相关的特性，但是Nginx仍然是一个不错的选择。&lt;/p&gt;

&lt;p&gt;如果您的流量需要为缓存添加一层基础设施，但不需要引入学习和维护的新技术的开销，Nginx可能更适合。&lt;/p&gt;

&lt;p&gt;如果您碰巧使用Nginx Plus，它具有支持和额外的功能，这一点尤其如此。&lt;/p&gt;

&lt;h1 id=&quot;用例&quot;&gt;用例&lt;/h1&gt;

&lt;p&gt;Nginx自己处理静态内容。这是Web服务器的典型用例，而不是缓存服务器。然而，由于Nginx可以向其他Web服务器或应用程序（通过HTTP，FastCGI和uWSGI）代理请求，因此通常用于在向其他进程代理应用程序请求时提高服务静态文件的性能。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是一个常见的架构，但是PHP的用户可能会使用Apache + Apache的&lt;code class=&quot;highlighter-rouge&quot;&gt;mod_php&lt;/code&gt;，它将PHP“内置”到Apache中，使得它似乎一切都在一个神奇（但效率较低）的地方。
除了直接提供静态文件的能力外，Nginx还可以作为缓存服务器，这意味着Nginx可以缓存从其他服务器接收的内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以下用例是使用Nginx作为缓存服务器的一些常见的用例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nginx可以位于Web服务器的前端，这可能是其他Nginx实例或Web应用程序。这是缓存服务器的典型用例 - 它作为其他Web或应用程序服务器的网关，起到了负载平衡器的作用。&lt;/li&gt;
  &lt;li&gt;Nginx缓存可以与负载均衡器一起使用。&lt;/li&gt;
  &lt;li&gt;实际上，Nginx可以充当负载平衡器和缓存服务器！&lt;/li&gt;
  &lt;li&gt;除了其他HTTP服务器/监听器之外，Nginx还可以缓存代理到FastCGI和uWSGI进程的请求结果！一个很好的用例是缓存内容管理系统（CMS）的结果，大多数用户不需要网站的动态方面 - 他们只是想看到内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;缓存服务器的主要优点&lt;/strong&gt;是我们在我们的应用服务器上放置的负载较少。对缓存的静态或动态资产的请求无需甚至到达应用程序（或静态内容）服务器 - 我们的缓存服务器本身可以处理许多请求！&lt;/p&gt;

&lt;p&gt;在这里的例子中，我们使用Nginx处理静态站点，再在前面放置Nginx缓存服务器。&lt;/p&gt;

&lt;h1 id=&quot;它如何工作&quot;&gt;它如何工作&lt;/h1&gt;

&lt;p&gt;首先你需要知道Origin Server是什么。&lt;/p&gt;

&lt;p&gt;源服务器是拥有真正的静态文件或动态生成的HTML的服务器。他们有两个责任：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;请求时提供动态和静态内容&lt;/li&gt;
  &lt;li&gt;通过HTTP缓存头决定如何缓存文件（和潜在的动态内容）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来说下&lt;strong&gt;缓存服务器&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;缓存服务器（通常）是“前端”;它从客户端收到初始HTTP请求。然后它会处理请求本身（如果它具有所请求资源的新缓存副本），或者将请求传递给Origin Server来实现。&lt;/p&gt;

&lt;p&gt;如果请求发送到Origin Server，则由Cache Server读取源服务器的响应头，以确定响应是缓存还是简单传递。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一些较大的Web应用程序除了缓存服务器之外还使用负载平衡器，从而导致高度分层的基础架构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;缓存服务器的职责：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;确定HTTP请求是否接受缓存响应，并且缓存中有一个新项目可以响应&lt;/li&gt;
  &lt;li&gt;如果请求不应被缓存，或者缓存的项目是否过期，则向源服务器发送HTTP请求&lt;/li&gt;
  &lt;li&gt;响应来自其缓存或源服务器的HTTP响应为适当的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后说下&lt;strong&gt;客户端&lt;/strong&gt;。客户端可以拥有自己的本地（私有）缓存 - 例如每个浏览器都有一个本地缓存。我们的浏览器可能会缓存一个响应本身（通常是图像，CSS和JS文件），因此，如果静态文件在其本地缓存中已经有新版本，那么浏览器根本不会向缓存服务器发送请求。&lt;/p&gt;

&lt;p&gt;实现本地缓存的客户端具有以下职责：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发送请求&lt;/li&gt;
  &lt;li&gt;缓存响应&lt;/li&gt;
  &lt;li&gt;决定从本地缓存中提取请求或发出HTTP请求以检索它们&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;源服务器&quot;&gt;源服务器&lt;/h1&gt;

&lt;p&gt;源服务器最终负责提供文件和控制如何缓存文件。&lt;/p&gt;

&lt;p&gt;客户端可以请求不被缓存的资源。缓存服务器“必须”遵守HTTP规范。&lt;/p&gt;

&lt;p&gt;此外，客户端请求可缓存资源时，必须遵循从源服务器返回的缓存参数，这可能包括不缓存结果的指令！&lt;/p&gt;

&lt;p&gt;这意味着我们需要确定文件如何缓存在我们的源服务器上。 为此，我通常将&lt;a href=&quot;https://github.com/h5bp/server-configs-nginx/tree/master/h5bp&quot;&gt;H5BP配置目录&lt;/a&gt;复制到&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/nginx/h5bp&lt;/code&gt;,作为Nginx服务器配置。&lt;/p&gt;

&lt;p&gt;复制H5BP文件之后，我可以在源服务器的Nginx虚拟主机中包含&lt;code class=&quot;highlighter-rouge&quot;&gt;basic.conf&lt;/code&gt;配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    # Note that it's listening on port 9000
    listen 9000 default_server;
    root /var/www/;
    index index.html index.htm;

    server_name example.com www.example.com;

    charset utf-8;
    include h5bp/basic.conf;

    location / {
        try_files $uri $uri/ =404;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与缓存最相关的H5BP配置文件是&lt;code class=&quot;highlighter-rouge&quot;&gt;expires.conf&lt;/code&gt;，它确定了常见文件的缓存行为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Expire rules for static content

# cache.appcache, your document html and data
location ~* \.(?:manifest|appcache|html?|xml|json)$ {
  expires -1;
  # access_log logs/static.log; # I don't usually include a static log
}

# Feed
location ~* \.(?:rss|atom)$ {
  expires 1h;
  add_header Cache-Control &quot;public&quot;;
}

# Media: images, icons, video, audio, HTC
location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ {
  expires 1M;
  access_log off;
  add_header Cache-Control &quot;public&quot;;
}

# CSS and Javascript
location ~* \.(?:css|js)$ {
  expires 1y;
  access_log off;
  add_header Cache-Control &quot;public&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述配置禁用&lt;code class=&quot;highlighter-rouge&quot;&gt;manifest&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;appcache&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;html&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;文件的缓存。 它将&lt;code class=&quot;highlighter-rouge&quot;&gt;RSS&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ATOM&lt;/code&gt;订阅文件缓存1小时，&lt;code class=&quot;highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;CSS&lt;/code&gt;文件1年，以及其他静态文件（图像和媒体）1个月。&lt;/p&gt;

&lt;p&gt;缓存全部设置为“public”，所以任何系统都可以缓存它们。 将它们设置为私有将限制它们被私有缓存（例如我们的浏览器）缓存。&lt;/p&gt;

&lt;p&gt;所以源服务器本身没有进行任何缓存，只是说文件应该根据文件扩展名进行缓存。 H5BP为设置缓存规则提供了不错的参考。&lt;/p&gt;

&lt;p&gt;如果直接向源服务器发出请求，我们可以看到这些规则生效。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原始服务器我设置来测试这个恰好是运行在127.17.0.18:9000&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以&lt;code class=&quot;highlighter-rouge&quot;&gt;.html&lt;/code&gt;结尾的文件不会被缓存。 我们可以看到响应如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# GET curl request and select response headers
$ curl -X GET -I 127.17.0.18:9000/index.html
HTTP/1.1 200 OK
Server: nginx/1.4.6 (Ubuntu)
Date: Fri, 05 Sep 2014 23:24:52 GMT
Content-Type: text/html
Last-Modified: Fri, 05 Sep 2014 22:16:24 GMT
Expires: Fri, 05 Sep 2014 23:24:52 GMT
Cache-Control: no-cache
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;请注意，Expires与Date相同，表示该请求立即到期，即告诉客户端不要缓存。 响应还返回头信息&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control：no-cache&lt;/code&gt;来表明不缓存响应内容。 这完全遵循H5BP &lt;code class=&quot;highlighter-rouge&quot;&gt;expires.conf&lt;/code&gt;配置设置的&lt;code class=&quot;highlighter-rouge&quot;&gt;.html&lt;/code&gt;文件的规则。&lt;/p&gt;

&lt;p&gt;接下来，我们可以尝试获取一个需要缓存的文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# GET curl request and select response headers
$ curl -X GET -I 127.17.0.18:9000/css/style.css
HTTP/1.1 200 OK
Server: nginx/1.4.6 (Ubuntu)
Date: Fri, 05 Sep 2014 23:25:04 GMT
Content-Type: text/css
Last-Modified: Fri, 05 Sep 2014 22:46:39 GMT
Expires: Sat, 05 Sep 2015 23:25:04 GMT
Cache-Control: max-age=31536000
Cache-Control: public
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以看到这个css文件在当前日期的1年后过期！ 缓存规则的设置&lt;code class=&quot;highlighter-rouge&quot;&gt;max-age&lt;/code&gt;(过期时间）大约为1年（以秒为单位），并允许公共缓存。 这也遵循了H5BP &lt;code class=&quot;highlighter-rouge&quot;&gt;expires.conf&lt;/code&gt;里设置的&lt;code class=&quot;highlighter-rouge&quot;&gt;.css&lt;/code&gt;文件的规则。&lt;/p&gt;

&lt;p&gt;至此，源服务器设置好了。&lt;/p&gt;

&lt;h1 id=&quot;缓存服务器&quot;&gt;缓存服务器&lt;/h1&gt;

&lt;p&gt;源服务器已经设置完毕，但是我们需要在源服务器前面放置一个缓存服务器。 在我们的场景中，缓存服务器将作为Web服务器来接收请求。 如果缓存服务器不能直接从缓存里命中文件，则它会将HTTP请求传递给源服务器。&lt;/p&gt;

&lt;p&gt;在开始安装新的Nginx之前，我们可以先看一下反向代理的“标准”设置。以下设置尚未配置任何缓存，它只是实现将请求代理到源服务器的功能：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
    # Note that it's listening on port 80
    listen 80 default_server;
    root /var/www/;
    index index.html index.htm;

    server_name example.com www.example.com;

    charset utf-8;

    location / {
        include proxy_params;
        proxy_pass http://172.17.0.18:9000;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;只是简单地将请求代理到源服务器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里为测试而设置的缓存服务器监听在&lt;code class=&quot;highlighter-rouge&quot;&gt;172.17.0.13:80&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果我们在缓存服务器上发出请求，就像直接发送请求到源服务器一样。 这是因为缓存服务器当前没有缓存：它只是将请求传递给源服务器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -X GET -I 172.17.0.13/css/style.css
HTTP/1.1 200 OK
Server: nginx/1.4.6 (Ubuntu)
Date: Fri, 05 Sep 2014 23:30:07 GMT
Content-Type: text/css
Last-Modified: Fri, 05 Sep 2014 22:46:39 GMT
Expires: Sat, 05 Sep 2015 23:30:07 GMT
Cache-Control: max-age=31536000
Cache-Control: public
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在，我们添加必要的指令，实现从源服务器中获取Nginx缓存响应。 我们在上面定义的配置中，增加额外的缓存指令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Note that these are defined outside of the server block,
# altho they don't necessarily need to be
proxy_cache_path /tmp/nginx levels=1:2 keys_zone=my_zone:10m inactive=60m;
proxy_cache_key &quot;$scheme$request_method$host$request_uri&quot;;

server {
    # Note that it's listening on port 80
    listen 80 default_server;
    root /var/www/;
    index index.html index.htm;

    server_name example.com www.example.com;

    charset utf-8;

    location / {
        proxy_cache my_zone;
        add_header X-Proxy-Cache $upstream_cache_status;

        include proxy_params;
        proxy_pass http://172.17.0.18:9000;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;以下解释一下缓存指令。&lt;/p&gt;

&lt;h2 id=&quot;proxy_cache_path&quot;&gt;proxy_cache_path&lt;/h2&gt;

&lt;p&gt;这是保存缓存文件的路径。 &lt;code class=&quot;highlighter-rouge&quot;&gt;levels&lt;/code&gt;指令设置缓存文件如何保存到文件系统。如果没有定义，缓存文件直接保存在指定的路径中。如果这样定义（&lt;code class=&quot;highlighter-rouge&quot;&gt;1：2&lt;/code&gt;），缓存文件将根据其md5哈希值保存在缓存路径的子目录中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;keys_zone&lt;/code&gt;是缓存区域的名称。这里它被命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;my_zone&lt;/code&gt;，并为缓存key和其他元数据提供了10MB的存储空间，尽管这并不限制可以缓存的文件数量！它只是设置元数据的存储空间。文档声称1MB区可以存储约8000个key和元数据。&lt;/p&gt;

&lt;p&gt;最后，我们设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;inactive&lt;/code&gt;指令，它告诉Nginx在60分钟内清除任何没有访问的缓存。请注意，这里&lt;code class=&quot;highlighter-rouge&quot;&gt;60m&lt;/code&gt;是60分钟，而&lt;code class=&quot;highlighter-rouge&quot;&gt;key_zone&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;10m&lt;/code&gt;是10兆字节。如果未显式设置，则&lt;code class=&quot;highlighter-rouge&quot;&gt;inactive&lt;/code&gt;指令默认为10分钟。&lt;/p&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;inactive&lt;/code&gt;使Nginx有机会“忘记”关于不常被请求的缓存资源。这样一来，Nginx缓存可以让您最大程度的降低成本 - 最需要的资源会保留在缓存中（并遵循愿服务器所指示的缓存规则）。&lt;/p&gt;

&lt;h2 id=&quot;proxy_cache_key&quot;&gt;proxy_cache_key&lt;/h2&gt;

&lt;p&gt;这是用来区分缓存文件的key。 默认值为&lt;code class=&quot;highlighter-rouge&quot;&gt;$scheme$proxy_host$uri$is_args$args&lt;/code&gt;，但是我们可以根据需要进行更改。&lt;/p&gt;

&lt;p&gt;proxy_cache_key也可以设置为类似&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;$host$request_uri $cookie_user&quot;&lt;/code&gt;（带引号）这样的形式，也可以包括cookies信息。&lt;/p&gt;

&lt;p&gt;Cookie确实会影响缓存，所以请谨慎设置！ 如果Cookie被并入缓存密钥，您可能会意外地Nginx为每个独立cookie（每个站点访问者）都创建了重复缓存的文件。&lt;/p&gt;

&lt;p&gt;这意味着将Cookie并入key确实会降低缓存的有效性。 针对每个用户的缓存，是私有缓存（Web浏览器）的目的，而不是我们正在构建的“公共”缓存服务器的目的。 但是，在某种情景下确实需要引入Cookie，那么proxy_cache_key的这个选项就很有用了。&lt;/p&gt;

&lt;h2 id=&quot;proxy_cache&quot;&gt;proxy_cache&lt;/h2&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;location&lt;/code&gt;块内，Nginx以&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_cache my_zone&lt;/code&gt;指令定义缓存区域。&lt;/p&gt;

&lt;p&gt;我们还添加了一个有用的header（头信息）来通知我们资源是否从缓存提供。这可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_header X-Proxy-Cache $ upstream_cache_status&lt;/code&gt;指令完成。 这将设置一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;X-Proxy-Cache&lt;/code&gt;的响应头，值为&lt;code class=&quot;highlighter-rouge&quot;&gt;HIT&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;MISS&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;BYPASS&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;保存配置文件后，重新加载Nginx的配置（&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo service nginx reload&lt;/code&gt;），并再次尝试HTTP请求。&lt;/p&gt;

&lt;p&gt;首次获取CSS文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# GET curl request and selected headers
$ curl -X GET -I 172.17.0.13/css/style.css
Date: Fri, 05 Sep 2014 23:50:12 GMT
Content-Type: text/css
Last-Modified: Fri, 05 Sep 2014 22:46:39 GMT
Expires: Sat, 05 Sep 2015 23:50:12 GMT
Cache-Control: max-age=31536000
Cache-Control: public
X-Proxy-Cache: MISS
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为之前没有请求过该文件，所以这里返回的cache状态为MISS。缓存服务器需要向源服务器请求资源。
再试一次：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# GET curl request and selected headers
$ curl -X GET -I 172.17.0.13/css/style.css
Date: Fri, 05 Sep 2014 23:50:48 GMT
Content-Type: text/css
Last-Modified: Fri, 05 Sep 2014 22:46:39 GMT
Expires: Sat, 05 Sep 2015 23:50:12 GMT
Cache-Control: max-age=31536000
Cache-Control: public
X-Proxy-Cache: HIT
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以看到，第二个请求和第一个请求相差不到30秒。 我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;X-Proxy-Cache&lt;/code&gt;头信息看到缓存状态是&lt;code class=&quot;highlighter-rouge&quot;&gt;HIT&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires&lt;/code&gt;头信息保持不变，因为Nginx只是从缓存中返回资源。 当缓存服务器返回到源服务器获取新文件时，那些头信息将会更新。&lt;/p&gt;

&lt;p&gt;安装现在的设置，Nginx将忽略客户端的&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control&lt;/code&gt;请求头。 但是，有些Web客户端不想使用缓存项目，我们希望缓存服务器能够支持这种要求。&lt;/p&gt;

&lt;p&gt;例如，使用浏览器打开网页时，按住SHIFT，同时单击重新加载按钮，这时浏览器将发送一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control: no-cache&lt;/code&gt;。 这要求缓存服务器不提供资源的缓存版本。 但目前我们的设置会将之忽略。&lt;/p&gt;

&lt;p&gt;为了在请求时适当地绕过缓存，我们可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;location&lt;/code&gt;块中将&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_cache_bypass $http_cache_control&lt;/code&gt;指令添加到缓存服务器中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location / {
    proxy_cache my_zone;
    proxy_cache_bypass  $http_cache_control;
    add_header X-Proxy-Cache $upstream_cache_status;

    include proxy_params;
    proxy_pass http://172.17.0.18:9000;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;nginx reload 之后，可以看到设置生效了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -X GET -I 172.17.0.13/css/style.css
...
X-Proxy-Cache: HIT     # A regular request which is normally a cache HIT ...

$ curl -X GET -I -H &quot;Cache-Control: no-cache&quot; 172.17.0.13/css/style.css
...
X-Proxy-Cache: BYPASS  # ... is now bypassed when told to
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_cache_bypass&lt;/code&gt;指令告知Nginx遵守HTTP请求中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control&lt;/code&gt;请求头。&lt;/p&gt;

&lt;h1 id=&quot;代理缓存&quot;&gt;代理缓存&lt;/h1&gt;

&lt;p&gt;Nginx的缓存功能强大！ 我们刚刚看到它可以缓存代理的HTTP请求，但是它也可以缓存FastCGI，uWSGI代理请求的结果，甚至缓存负载平衡请求（“upstream”）的结果。 这意味着我们可以缓存到动态应用程序的请求结果。&lt;/p&gt;

&lt;p&gt;如果我们使用Nginx来缓存FastCGI进程的结果，我们可以将FastCGI进程视为源服务器，将Nginx作为缓存服务器。 例如，在&lt;code class=&quot;highlighter-rouge&quot;&gt;fideloper.com&lt;/code&gt;上，我缓存了从PHP-FPM返回的HTML结果。&lt;/p&gt;

&lt;p&gt;这是一个使用&lt;code class=&quot;highlighter-rouge&quot;&gt;fastcgi_cache&lt;/code&gt;的示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fastcgi_cache_path /tmp/cache levels=1:2 keys_zone=fideloper:100m inactive=60m;
fastcgi_cache_key &quot;$scheme$request_method$host$request_uri&quot;;

server {

    # Boilerplay omitted

    set $no_cache 0;

    # Example: Don't cache admin area
    # Note: Conditionals are typically frowned upon :/
    if ($request_uri ~* &quot;/(admin/)&quot;)
    {
        set $no_cache 1;
    }

    location ~ ^/(index)\.php(/|$) {
            fastcgi_cache fideloper;
            fastcgi_cache_valid 200 60m; # Only cache 200 responses, cache for 60 minutes
            fastcgi_cache_methods GET HEAD; # Only GET and HEAD methods apply
            add_header X-Fastcgi-Cache $upstream_cache_status;
            fastcgi_cache_bypass $no_cache;  # Don't pull from cache based on $no_cache
            fastcgi_no_cache $no_cache; # Don't save to cache based on $no_cache

            # Regular PHP-FPM stuff:
            include fastcgi.conf; # fastcgi_params for nginx &amp;lt; 1.6.1
            fastcgi_split_path_info ^(.+\.php)(/.+)$;
            fastcgi_pass unix:/var/run/php5-fpm.sock;
            fastcgi_index index.php;
            fastcgi_param LARA_ENV production;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的缓存设置选项很多。对于使用FastCGI缓存，请注意以下两点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;fastcgi_cache&lt;/code&gt;替换proxy_cache的所有实例&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;fastcgi_cache_valid 200 60m&lt;/code&gt;来设置PHP请求响应的到期时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你可以看到实际效果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -X GET -I fideloper.com/index.php
...
Cache-Control: max-age=86400, public
X-Fastcgi-Cache: MISS

$ curl -X GET -I fideloper.com/index.php
...
X-Fastcgi-Cache: HIT

# If this URL existed, you'd see a BYPASS
$ curl -X GET -I fideloper.com/admin
...
X-Fastcgi-Cache: BYPASS
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;相关资源&quot;&gt;相关资源&lt;/h1&gt;

&lt;p&gt;您可以使用缓存进行更多的操作，例如设置不进行缓存的情况（例如管理区域）以及清除缓存的方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.mnot.net/cache_docs/&quot;&gt;Learn about Web Caches&lt;/a&gt; , 作者是Mark Nottingham，IETF组织HTTP工作组主席，W3C技术架构组的成员。 建议所有网站开发者都阅读。还有 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616.html&quot;&gt;HTTP Specification&lt;/a&gt; 也很有参考价值。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.com/resources/admin-guide/caching/&quot;&gt;Nginx Admin Guide on Caching&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html&quot;&gt;HTTP Cache Docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&quot;&gt;FastCGI Cache docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html&quot;&gt;uWSGI Cache Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;本文翻译自&lt;a href=&quot;https://serversforhackers.com/nginx-caching&quot;&gt;Nginx Caching&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&quot;https://translate.google.com&quot;&gt;谷歌翻译&lt;/a&gt;，它出色的效果减少了博主很多工作量。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>在线编辑器增加本地自动保存功能[Editor.md,UEditor]</title>
   <link href="http://spetacular.github.io/2017/04/07/editor-md-auto-save-markdown.html"/>
   <updated>2017-04-07T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/04/07/editor-md-auto-save-markdown</id>
   <content type="html">&lt;p&gt;UEditor 增加本地自动保存功能，更新于2017年11月17日。&lt;/p&gt;

&lt;h1 id=&quot;editormd&quot;&gt;Editor.md&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://pandao.github.io/editor.md/&quot;&gt;Editor.md&lt;/a&gt; 是一款开源 Markdown 在线编辑器。在编辑较长文章时，为防止疏忽造成内容丢失，可以添加自动保存功能。&lt;/p&gt;

&lt;p&gt;预览地址：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.text.wiki/md/&quot;&gt;https://www.text.wiki/md/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;利用localStorage来暂存数据。当文本框有改动时，将内容存到localStorage里；当页面再次加载时，读取localStorage的值。&lt;/p&gt;

&lt;p&gt;假设页面创建的编辑器命名为 mdEditor ,则只需将以下js加入页面即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    var key = 'default_md_key';
    mdEditor.on(&quot;load&quot;, function(){
        var content = localStorage.getItem(key);
        if(content){
            var f = confirm(&quot;您上次编辑的文章未提交，是否恢复？内容：\n&quot;+content);
            if(f == true){
                testEditor.setValue(content)
            }
        }
    })

    mdEditor.on(&quot;change&quot;, function(){
        localStorage.setItem(key,this.getValue())
    })
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用户向服务器提交数据并保存成功后，可以删掉key。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;localStorage.removeItem(key);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;ueditor&quot;&gt;UEditor&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://ueditor.baidu.com/website/index.html&quot;&gt;UEditor&lt;/a&gt; 本身有自动保存功能，但并不好用，这里也说明一下配置方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var key = 'default_ue_key';
var ue = UE.getEditor('editor');
    ue.addListener( 'ready', function( editor ) {
        var content = localStorage.getItem(key);
        if(content){
            var f = confirm(&quot;您上次编辑的文章未提交，是否恢复？内容：\n&quot;+content);
            if(f == true){
                UE.getEditor('editor').execCommand('insertHtml', content);
            }
        }
    } );

    ue.addListener('contentchange',function(){
        var content = UE.getEditor('editor').getContent();
        localStorage.setItem(key,content);
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;用户向服务器提交数据并保存成功后，可以删掉key。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;localStorage.removeItem(key);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>小程序新能力：公众号自定义菜单点击打开相关小程序</title>
   <link href="http://spetacular.github.io/2017/03/31/weixin-mp-open-minapp-in-menu.html"/>
   <updated>2017-03-31T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/03/31/weixin-mp-open-minapp-in-menu</id>
   <content type="html">&lt;p&gt;微信在2017年3月27日发布了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDAwMTA2MA==&amp;amp;mid=2695729676&amp;amp;idx=1&amp;amp;sn=2f0279377bcc6b0ea14d30389dfde698&amp;amp;chksm=83d74bc7b4a0c2d197ebad8e77b4e6a3f5c19a6ef91f0602b4a695d2ef0994fd1e6431a5babb&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0327yIBkOfW0f1CEF7Sc1MY2#rd&quot;&gt;《小程序新能力》&lt;/a&gt;的重要更新，主要新增了以下功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;个人开发者可申请小程序&lt;/li&gt;
  &lt;li&gt;公众号自定义菜单点击可打开相关小程序&lt;/li&gt;
  &lt;li&gt;公众号模版消息可打开相关小程序&lt;/li&gt;
  &lt;li&gt;公众号关联小程序时，可选择给粉丝下发通知&lt;/li&gt;
  &lt;li&gt;移动App可分享小程序页面&lt;/li&gt;
  &lt;li&gt;扫描普通链接二维码可打开小程序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文主要说明实现公众号自定义菜单点击打开相关小程序。&lt;/p&gt;

&lt;p&gt;公众号可将已关联的小程序页面放置到自定义菜单中，用户点击后可打开该小程序页面。公众号运营者可在公众平台进行设置，也可以通过自定义菜单接口进行设置。&lt;/p&gt;

&lt;h1 id=&quot;1公众平台设置方式&quot;&gt;1.公众平台设置方式&lt;/h1&gt;
&lt;h2 id=&quot;11关联小程序&quot;&gt;1.1关联小程序&lt;/h2&gt;

&lt;p&gt;当读者使用公众平台设置方式时，首先要关联公众号和小程序。打开公众平台https://mp.weixin.qq.com，打开“设置” –&amp;gt; “公众号设置”，可以看到如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/mp-add-relative-minapp.png&quot; alt=&quot;公众平台公众号设置，关联小程序&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击“添加”按钮，即进入小程序添加页面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/mp-add-relative-minapp-2.png&quot; alt=&quot;公众平台公众号设置，关联小程序&quot; /&gt;&lt;/p&gt;

&lt;p&gt;扫码验证身份后，即可关联小程序。再输入框输入小程序的AppID，点击搜索按钮，即可完成关联。&lt;/p&gt;

&lt;p&gt;注意，只能关联公众号主体一致的小程序。就是说，公共号和小程序的主体如果是个人，则必须是同一个人；如果是企业，则必须是同一企业。&lt;/p&gt;

&lt;p&gt;公众号关联小程序时，可勾选“关联后给已关注公众号的用户发送通知”，给粉丝下发通知消息，粉丝点击该通知消息可以打开小程序。该消息不占用原有群发条数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/mp-add-relative-minapp-3.png&quot; alt=&quot;公众平台公众号设置，关联小程序&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;12设置小程序自定义菜单&quot;&gt;1.2设置小程序自定义菜单&lt;/h2&gt;

&lt;p&gt;可以在“功能管理”下“自定义菜单”下编辑，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/mp-add-relative-minapp-4.png&quot; alt=&quot;公众平台公众号设置，关联小程序&quot; /&gt;&lt;/p&gt;

&lt;p&gt;填写要素有：&lt;/p&gt;

&lt;p&gt;1.菜单名称：底部自定义菜单展示的文字；&lt;/p&gt;

&lt;p&gt;2.跳转类型：选择“跳转小程序”Tab；&lt;/p&gt;

&lt;p&gt;3.小程序路径：填入小程序路径&lt;/p&gt;

&lt;p&gt;4.备用网页：旧版兼容选项。旧版微信客户端无法支持小程序时，用户点击菜单时将会打开备用网页。&lt;/p&gt;

&lt;h1 id=&quot;2开发模式自定义菜单创建&quot;&gt;2.开发模式自定义菜单创建&lt;/h1&gt;

&lt;p&gt;在开发模式下，可以通过自定义菜单创建接口来创建小程序的菜单。文档地址为&lt;a href=&quot;https://mp.weixin.qq.com/wiki&quot;&gt;https://mp.weixin.qq.com/wiki&lt;/a&gt;下的“自定义菜单”页面。&lt;/p&gt;

&lt;p&gt;接口地址如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;请求内容示例如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;button&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;miniprogram&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;小程序&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;appid&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;wx1dda1f639e823874&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://www.qq.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;pagepath&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;page/index&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;完整程序如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
define('APPID', '公众号APPID ');//公众号APPID
define('APPSECRET', '公众号APPSECRET ');//公众号APPSECRET
//$menu变量为存放菜单项的json字符串
$menu =
	'{
&quot;button&quot;: [
{
&quot;type&quot;: &quot;miniprogram&quot;,
&quot;name&quot;: &quot;小程序&quot;,
&quot;appid&quot;: &quot;请填写小程序ID&quot;,
&quot;url&quot;: &quot;http://www.qq.com&quot;,
&quot;pagepath&quot;: &quot;page/index&quot;
}
]
}';
$url = &quot;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=&quot; . get_token();
$content = curl_post($url, $menu);
$ret = json_decode($content, true);
if ($ret['errcode'] == 0) {//创建成功
	echo 'create menu ok';
} else {//创建失败
	echo 'create menu fail,msg:' . $ret['errmsg'];
}
function curl_post($url, $post_string) {
	$ch = curl_init();
	curl_setopt($ch, CURLOPT_URL, $url);
	curl_setopt($ch, CURLOPT_POSTFIELDS, $post_string);
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
	$data = curl_exec($ch);
	curl_close($ch);
	return $data;
}
function curl_get($url) {
	$ch = curl_init();
	curl_setopt($ch, CURLOPT_URL, $url);;
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
	curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
	curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);
	if (!curl_exec($ch)) {
		$data = '';
	} else {
		$data = curl_multi_getcontent($ch);
	}
	curl_close($ch);
	return $data;
}
function get_token() {
	$url = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;amp;appid=&quot; . APPID . &quot;&amp;amp;secret=&quot; . APPSECRET;
	$content = curl_get($url);
	$ret = json_decode($content, true);//{&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200}
	if (array_key_exists('errcode', $ret) &amp;amp;&amp;amp; $ret['errcode'] != 0) {
		return false;
	} else {
		return $ret['access_token'];
	}
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;欢迎加入微信开发者小密圈&quot;&gt;欢迎加入微信开发者小密圈&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;微信开放平台拥有订阅号、服务号、小程序和企业号，吸引了一大批开发者，也形成了独特的生态圈。希望我们能吸收能量，交换信息，自由生长。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PC端点击链接：&lt;a href=&quot;https://wx.xiaomiquan.com/mweb/views/joingroup/join_group.html?group_id=4221251218&amp;amp;secret=7hrxv8fo5gg7qnjagobezs1g05wsus91&amp;amp;extra=03805215ea752e7e60e44178c4f4f15003ec659aa155aacda4ae846184cea8fe&quot;&gt;微信生态圈小密圈&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;微信扫码：
&lt;img src=&quot;http://wx4.sinaimg.cn/large/7ed0a961ly1fdb80fejqmj20k20u8diq.jpg&quot; alt=&quot;微信生态圈&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>教程：配置 Let's Encrypt 免费HTTPS证书</title>
   <link href="http://spetacular.github.io/2017/03/29/lets-encrypt-deploy-step-by-step.html"/>
   <updated>2017-03-29T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/03/29/lets-encrypt-deploy-step-by-step</id>
   <content type="html">&lt;h2 id=&quot;最新更新&quot;&gt;最新更新&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://certbot.eff.org&quot;&gt;Certbot&lt;/a&gt; 更新了自动更新脚本，现在配置更简单了,基本实现全自动化。以 Nginx 和 Ubuntu 16.04 为例：&lt;/p&gt;

&lt;h3 id=&quot;1-安装-certbot-软件&quot;&gt;1. 安装 certbot 软件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install software-properties-common
$ sudo add-apt-repository ppa:certbot/certbot
$ sudo apt-get update
$ sudo apt-get install python-certbot-nginx 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2-一键安装脚本&quot;&gt;2. 一键安装脚本&lt;/h3&gt;
&lt;p&gt;certbot 附带一个 nginx 插件，可以直接生成证书和写入nginx配置文件中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo certbot --nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3-自动更新&quot;&gt;3. 自动更新&lt;/h3&gt;
&lt;p&gt;将自动更新脚本加入crontab中，每月自动更新，crontab -e 加入以下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 0 1 * * certbot renew
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;目录定义&quot;&gt;目录定义&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;存放验证域名的文件，即acme-dir，默认存储在/home/xxx/www/challenges/&lt;/li&gt;
  &lt;li&gt;存放最终结果证书的目录，如本文中的/data/ssl&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;存放验证域名文件的目录&quot;&gt;存放验证域名文件的目录&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     mkdir ~/www/challenges/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后配置一个 HTTP 服务，以 Nginx 为例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NGINX
    server {
        server_name www.yoursite.com yoursite.com;

        location ^~ /.well-known/acme-challenge/ {
            alias /home/xxx/www/challenges/;
            try_files $uri =404;
        }

        location / {
            rewrite ^/(.*)$ https://yoursite.com/$1 permanent;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后重启nginx。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language- &quot;&gt; sudo service nginx reload
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;创建存放证书的目录&quot;&gt;创建存放证书的目录&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mkdir /data/ssl
    cd /data/ssl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;创建一个-rsa-私钥用于-lets-encrypt-识别你的身份&quot;&gt;创建一个 RSA 私钥用于 Let’s Encrypt 识别你的身份&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    openssl genrsa 4096 &amp;gt; account.key
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;创建-rsa-私钥兼容性好&quot;&gt;创建 RSA 私钥（兼容性好）&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    openssl genrsa 4096 &amp;gt; domain.key
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;common-name-必须为你的域名其它的随便填&quot;&gt;Common Name 必须为你的域名，其它的随便填&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    openssl req -new -sha256 -key domain.key -out domain.csr
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;获取脚本&quot;&gt;获取脚本&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;指定账户私钥csr-以及验证目录执行脚本&quot;&gt;指定账户私钥、CSR 以及验证目录，执行脚本：&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /home/xxx/www/challenges/ &amp;gt; ./signed.crt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果一切正常，当前目录下就会生成一个 signed.crt，这就是申请好的证书文件。&lt;/p&gt;
&lt;h2 id=&quot;证书融合&quot;&gt;证书融合&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &amp;gt; intermediate.pem
cat signed.crt intermediate.pem &amp;gt; chained.pem
    wget -O - https://letsencrypt.org/certs/isrgrootx1.pem &amp;gt; root.pem
cat intermediate.pem root.pem &amp;gt; full_chained.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;ssl配置&quot;&gt;ssl配置&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    server {
        listen 443;
        server_name www.text.wiki;
        root   /data/htdocs/textwiki;
        autoindex on;
        index index.php index.html;
        ssl on;
        ssl_certificate /data/ssl/chained.pem;
        ssl_certificate_key /data/ssl/domain.key;
        ssl_protocols              TLSv1 TLSv1.1 TLSv1.2;
        ssl_trusted_certificate    /data/ssl/full_chained.pem;

        location / {
                    try_files $uri $uri/ /index.php;

                    location ~ \.php$ {
                        fastcgi_pass unix:/var/run/php5-fpm.sock;
                        fastcgi_param  SCRIPT_FILENAME /data/htdocs/textwiki$fastcgi_script_name;
                        include        fastcgi_params;
                    }
                }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;自动更新脚本&quot;&gt;自动更新脚本&lt;/h2&gt;
&lt;p&gt;1.新建文件&lt;code class=&quot;highlighter-rouge&quot;&gt;vi renew_cert.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.填写如下内容&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
    cd /data/ssl/
    python acme_tiny.py --account-key account.key --csr domain.csr --acme-dir /home/xxx/www/challenges/ &amp;gt; signed.crt &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;exit
    &lt;/span&gt;wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &amp;gt; intermediate.pem
    cat signed.crt intermediate.pem &amp;gt; chained.pem
    wget -O - https://letsencrypt.org/certs/isrgrootx1.pem &amp;gt; root.pem
cat intermediate.pem root.pem &amp;gt; full_chained.pem
    service nginx reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;3.&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod +x renew_cert.sh&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;加入crontab&quot;&gt;加入crontab&lt;/h2&gt;

&lt;p&gt;crontab 中加入自动更新脚本，每月自动更新，crontab -e 加入以下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    0 0 1 * * /data/ssl/renew_cert.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;最关键的是如果服务器有防火墙请放开服务器的443入口&quot;&gt;最关键的是，如果服务器有防火墙，请放开服务器的443入口&lt;/h2&gt;

&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;本文注重实战，跟着教程一步一步配置即可，想了解原理的同学，可以参考如下网址：   &lt;br /&gt;
&lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt官网&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;https://imququ.com/post/letsencrypt-certificate.html&quot;&gt;Let’s Encrypt，免费好用的 HTTPS 证书&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;https://ksmx.me/letsencrypt-ssl-https/&quot;&gt;Let’s Encrypt 给网站加 HTTPS 完全指南&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Docker:网络配置</title>
   <link href="http://spetacular.github.io/2017/03/20/docker-network-settings.html"/>
   <updated>2017-03-20T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/03/20/docker-network-settings</id>
   <content type="html">&lt;p&gt;Docker运行容器时，一个常见的问题是：localhost(127.0.0.1)指向哪里？这涉及到Docker的网络配置问题。&lt;/p&gt;

&lt;!-- Docker 一个常用用法是开放特定端口来对外提供服务，如 Mysql 占用3306端口，redis 占用 6379 端口。这样就牵扯到网络配置的问题（以 Mysql 为例）：    
1. localhost(127.0.0.1)指向哪里？     
2. [宿主机](/2017/03/10/docker-basic-concept.html#host)如何连接到Mysql服务所在的容器？   
3. 另一台运行在容器内的php服务如何连接到 Mysql 服务器所在的容器？ --&gt;

&lt;p&gt;Docker支持的网络模式如下：bridge（默认）、host、container、network-name、none。&lt;/p&gt;

&lt;h1 id=&quot;桥接-bridge&quot;&gt;桥接 bridge&lt;/h1&gt;
&lt;p&gt;Docker 默认的网络模式是 bridge 。在该模式下，docker 创建了一个 bridge，名称通常为 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt; 。 &lt;br /&gt;
可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;ifconfig&lt;/code&gt;来查看：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker0   Link encap:Ethernet  HWaddr **:**:**:**:**:**
          inet addr:192.168.0.1  Bcast:0.0.0.0  Mask:255.255.240.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:305002 errors:0 dropped:0 overruns:0 frame:0
          TX packets:407006 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:30331811 (30.3 MB)  TX bytes:752905683 (752.9 MB)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;宿主机和容器通过bridge进行通信，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2016/docker-networking-bridge-mode.jpeg&quot; alt=&quot;docker桥接bridge模式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;容器内的localhost指向容器内部。&lt;/p&gt;

&lt;h1 id=&quot;本机-host&quot;&gt;本机 host&lt;/h1&gt;
&lt;p&gt;当使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--net=host&lt;/code&gt;启动容器时，网络配置为 host 模式。该模式下，容器和宿主机共享网络。形象地讲，容器和宿主机共享一个网卡，在容器内的网络访问如同直接在宿主机上操作一样。例如：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm -it --net=host ubuntu:trusty bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;容器内的localhost指向宿主机。
&lt;img src=&quot;/images/2016/docker-networking-host-mode.jpeg&quot; alt=&quot;docker桥接host模式&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;container&quot;&gt;container&lt;/h1&gt;
&lt;p&gt;Docker可以指定一个容器复用另一个容器的网络设置。这种模式适用于由多个容器搭建整套系统的情况，例如搭建PHP开发环境时，希望Mysql、Redis都使用PHP容器的网络配置，即可以使用该模式。&lt;/p&gt;

&lt;h1 id=&quot;network-name&quot;&gt;network-name&lt;/h1&gt;
&lt;p&gt;Docker允许用户使用Docker network driver或[第三方network driver插件]（https://docs.docker.com/engine/extend/legacy_plugins/#network-plugins）创建自定义网络，然后多个容器都可以使用相同的网络。常见的第三方etwork driver插件有：&lt;a href=&quot;https://github.com/contiv/netplugin&quot;&gt;Contiv Networking&lt;/a&gt;、&lt;a href=&quot;https://github.com/openstack/kuryr&quot;&gt;Kuryr Network Plugin&lt;/a&gt;、&lt;a href=&quot;https://www.weave.works/docs/net/latest/introducing-weave/&quot;&gt;Weave Network Plugin&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&quot;none&quot;&gt;none&lt;/h1&gt;
&lt;p&gt;顾名思义，该模式下没有网络连接。例如我的宿主机ip为192.168.0.59，在容器内访问宿主机就提示无网络。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -it --net=none my_ubuntu bash
root@6533968160dd:/# ping 192.168.0.59
connect: Network is unreachable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;!-- # Docker为什么没有 nat 模式 --&gt;
</content>
 </entry>
 
 <entry>
   <title>Docker:基本概念</title>
   <link href="http://spetacular.github.io/2017/03/10/docker-basic-concept.html"/>
   <updated>2017-03-10T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/03/10/docker-basic-concept</id>
   <content type="html">&lt;h1 id=&quot;镜像&quot;&gt;&lt;a href=&quot;#image&quot;&gt;镜像&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Docker镜像Image是一个就像具有&lt;a href=&quot;https://zh.wikipedia.org/wiki/Time_Machine&quot;&gt;Time Machine&lt;/a&gt;功能的虚拟机，保存着特定时刻的一个快照。这个快照包含了已安装的程序、共享库、配置文件、环境变量、用户组等信息。构建Image时，以上内容不会改变。这意味着可以利用Image快速复制出多个相同的运行实体（容器）。&lt;/p&gt;

&lt;h1 id=&quot;容器&quot;&gt;&lt;a href=&quot;#container&quot;&gt;容器&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Docker容器container是镜像Image的运行实体。一个镜像可以生成多个相同的容器，每个容器的代码、运行环境、系统工具、系统库都完全相同。这在环境部署、服务扩容等方面具有重大作用。&lt;/p&gt;

&lt;h1 id=&quot;仓库&quot;&gt;&lt;a href=&quot;#registry&quot;&gt;仓库&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Docker仓库Registry是一个镜像存储和分发的服务。一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。&lt;/p&gt;

&lt;h1 id=&quot;构建&quot;&gt;&lt;a href=&quot;#build&quot;&gt;构建&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;利用 &lt;a href=&quot;https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#run&quot;&gt;Dockerfile&lt;/a&gt; 定制镜像时，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;docker build&lt;/code&gt;命令，将指令构建为文件系统。&lt;/p&gt;

&lt;h1 id=&quot;宿主机&quot;&gt;&lt;a href=&quot;#host&quot;&gt;宿主机&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;宿主机就是运行Docker容器的机器。例如我在mac上用&lt;a href=&quot;https://docs.docker.com/docker-for-mac/&quot;&gt;Docker for Mac&lt;/a&gt;，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;docker pull ubuntu&lt;/code&gt;来拉取一个ubuntu镜像然后运行，那么宿主机指的是mac。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PHP异步任务队列管理器asyntask介绍</title>
   <link href="http://spetacular.github.io/2017/03/09/asyntask-desc.html"/>
   <updated>2017-03-09T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/03/09/asyntask-desc</id>
   <content type="html">&lt;h1 id=&quot;php异步任务队列管理器asyntask&quot;&gt;PHP异步任务队列管理器asyntask&lt;/h1&gt;
&lt;p&gt;asyntask是一个轻量级异步任务队列管理器，支持实时，定时，长时和周期任务。&lt;/p&gt;

&lt;h2 id=&quot;项目由来&quot;&gt;项目由来&lt;/h2&gt;

&lt;p&gt;本项目最初用于通知推送。例如用户发布评论，需要推送一条push给原作者。而到苹果的服务器的请求时间较长，如果等待苹果服务器的返回结果，则整个发布评论的接口的响应时间就太长了。因为推送push早1秒晚1秒对用户基本没影响，所以当用户发布评论时，只要数据到数据库，即可返回。与此同时创建一条异步任务，在1秒内给用户推送push。这样既保证了接口的响应速度，又不影响用户体验。该项目已经在线上环境运行1年多，执行了累计8千万条命令，运行稳定。&lt;/p&gt;

&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;异步执行&lt;/li&gt;
  &lt;li&gt;集成管理后台，可视化操作&lt;/li&gt;
  &lt;li&gt;代码集成，可编程&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;缺点&quot;&gt;缺点&lt;/h2&gt;

&lt;p&gt;并非真正实时，秒级误差。&lt;/p&gt;

&lt;h1 id=&quot;安装&quot;&gt;安装&lt;/h1&gt;
&lt;h2 id=&quot;下载源码&quot;&gt;下载源码&lt;/h2&gt;

&lt;p&gt;直接使用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/spetacular/asyntask.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;命令下载到本地。&lt;/p&gt;

&lt;p&gt;也可以点击 &lt;a href=&quot;https://github.com/spetacular/asyntask/archive/master.zip&quot;&gt;https://github.com/spetacular/asyntask/archive/master.zip&lt;/a&gt; 下载最新内容的压缩包，然后解压。&lt;/p&gt;
&lt;h2 id=&quot;通过-composer-来安装&quot;&gt;通过 composer 来安装&lt;/h2&gt;

&lt;p&gt;在你的 composer 项目中的 composer.json 文件中，添加这部分：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;require&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
           &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;davidyan/asyntask&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;gt;=1.0&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;composer install&lt;/code&gt;。调用示例如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;include './vendor/autoload.php';
$task = new AsynTask\Task();

//添加单次任务
$name = '单次任务';
$cmd = 'php abcd.php';
$params = array(
	'params'=&amp;gt;1
);
$task-&amp;gt;add_once_task($name,$cmd,$params);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;配置&quot;&gt;配置&lt;/h1&gt;
&lt;p&gt;1.asyntask的数据默认存储在Mysql数据库里，因此需要更改config.php里的配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	'DB_HOST'=&amp;gt;'127.0.0.1',
	'DB_NAME' =&amp;gt; 'asyntask',
	'DB_USER' =&amp;gt; 'root',
	'DB_PWD' =&amp;gt; '',
	'DB_PORT' =&amp;gt; '3306',
	'DB_CHARSET' =&amp;gt; 'utf8mb4',
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.导入数据表
将resource文件夹里的db.sql导入数据库中。&lt;/p&gt;

&lt;p&gt;3.配置健康检查脚本
run.sh定期检查异步任务的运行状况，如果挂了，cron_asyn_task.php脚本。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chmod +x run.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后配置CronTab。运行&lt;code class=&quot;highlighter-rouge&quot;&gt;crontab -e&lt;/code&gt;，然后添加一行：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* * * * *  path-to/run.sh  &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h1 id=&quot;使用方式&quot;&gt;使用方式&lt;/h1&gt;

&lt;h2 id=&quot;管理后台&quot;&gt;管理后台&lt;/h2&gt;

&lt;p&gt;自带管理后台，可以轻松添加、编辑、删除、搜索任务。代码在&lt;a href=&quot;https://github.com/spetacular/asynadmin&quot;&gt;https://github.com/spetacular/asynadmin&lt;/a&gt;，请自行部署。
&lt;a href=&quot;https://github.com/spetacular/asynadmin/raw/master/asynadmin.jpeg&quot;&gt;&lt;img src=&quot;https://github.com/spetacular/asynadmin/raw/master/asynadmin.jpeg&quot; alt=&quot;管理后台截图&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;编程方式&quot;&gt;编程方式&lt;/h2&gt;

&lt;p&gt;可以集成到项目中，完整使用示例见&lt;code class=&quot;highlighter-rouge&quot;&gt;test.php&lt;/code&gt;。
例如添加周期任务：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$name = '周期任务';
$cmd = 'php abc.php';
$params = array(
	'params'=&amp;gt;1
);
$timeOptions = array(
	'day'=&amp;gt;1,
	'hour'=&amp;gt;2,
	'minute'=&amp;gt;3
);
$task-&amp;gt;add_loop_task($name,$cmd,$params,$timeOptions);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id=&quot;周期任务示例&quot;&gt;周期任务示例&lt;/h2&gt;

&lt;p&gt;每天执行：day 1 hour 0 minute 0 每天零点执行&lt;/p&gt;

&lt;p&gt;每小时执行：day 0 hour 1 minute 5 每小时的5分执行&lt;/p&gt;

&lt;p&gt;每隔若干分钟执行：day 0 hour 0 minute 5 每隔5分钟执行&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>开发知识点记录</title>
   <link href="http://spetacular.github.io/2017/01/01/develop-tips.html"/>
   <updated>2017-01-01T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2017/01/01/develop-tips</id>
   <content type="html">&lt;h1 id=&quot;cron-任务没执行的原因&quot;&gt;cron 任务没执行的原因&lt;/h1&gt;

&lt;p&gt;查看 cron 日志，日志路径一般在：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/var/log/cron.log
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/var/log/syslog
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就能看到类似这样的错误：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Error: bad username; while reading /etc/crontab
(&lt;em&gt;system&lt;/em&gt;) ERROR (Syntax error, this crontab file will be ignored)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后按图索骥，查找失败原因。&lt;/p&gt;

&lt;h1 id=&quot;cron-启动关闭重启重载查看服务状态&quot;&gt;cron 启动、关闭、重启、重载、查看服务状态&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	service cron start    //启动服务
　　	service cron stop     //关闭服务
　　	service cron restart  //重启服务
　　	service cron reload   //重新载入配置
　　	service cron status   //查看服务状态 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;命令行输错命令如何快速撤销&quot;&gt;命令行输错命令如何快速撤销？&lt;/h1&gt;
&lt;p&gt;最笨的方法可以按删除键，一个一个删除；
&lt;img src=&quot;/images/2016/withdraw-input-1.gif&quot; alt=&quot;撤销命令&quot; /&gt;
最快的办法是Ctrl + U，一键清理。
&lt;img src=&quot;/images/2016/withdraw-input-2.gif&quot; alt=&quot;撤销命令&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;docker显示容器命令container-cmd详情&quot;&gt;docker显示容器命令(container CMD)详情&lt;/h1&gt;

&lt;script src=&quot;https://gist.github.com/spetacular/1df9fba67d5854f4ad203b19c9cc919c.js&quot;&gt;&lt;/script&gt;

&lt;h1 id=&quot;php生成形容hhmmss格式的时间&quot;&gt;php生成形容’HH:MM:SS’格式的时间&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gmstrftime('%H:%M:%S',$time)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo gmstrftime('%H:%M:%S',3786);
//Output: 01:03:06
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;chrome-下上传图片文件慢的解决办法&quot;&gt;chrome 下上传图片/文件慢的解决办法&lt;/h1&gt;

&lt;p&gt;最近用flow.js做的上传图片功能，突然变得很慢，要10秒左右才能打开上传对话框。查了一下，是mac chrome的一个bug。设置图片格式时，如果采用如下写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input type=&quot;file&quot; accept=&quot;image/*&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;则会重现。有网友反映，windows 10, chrome 53下也会有此问题。解决办法是，将image/*换为具体的格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input type=&quot;file&quot; accept=&quot;image/png, image/jpeg, image/gif&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://stackoverflow.com/questions/39187857/inputfile-accept-image-open-dialog-so-slow-with-chrome&quot;&gt;open dialog so slow with Chrome&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;redis-按前缀模式批量删除keys&quot;&gt;redis 按前缀/模式批量删除keys&lt;/h1&gt;
&lt;p&gt;有两种情况：
1.在redis外部，可以用 xargs；
2.在redis内部，可以用 eval 执行脚本
示例：
先创建一些key。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; set david1 1
OK
127.0.0.1:6379&amp;gt; set david2 2
OK
127.0.0.1:6379&amp;gt; keys david*
1) &quot;david2&quot;
2) &quot;david1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;方法1:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis-cli keys david* | xargs redis-cli del
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;方法2:
进入 redis 命令行。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; eval &quot;local keys = redis.call('keys',KEYS[1]) for i,v in ipairs(keys) do redis.call('del',v) end&quot; 1 david*
(nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;两种方法的结果如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; keys david*
(empty list or set)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>Restful API中的JSON模板解析－JSONOut库的介绍</title>
   <link href="http://spetacular.github.io/2016/08/01/json-template-to-json.html"/>
   <updated>2016-08-01T00:00:00+08:00</updated>
   <id>http://spetacular.github.io/2016/08/01/json-template-to-json</id>
   <content type="html">&lt;h2 id=&quot;项目地址&quot;&gt;项目地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spetacular/jsonout&quot;&gt;Restful API中的JSON模板解析&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;为什么需要json模板解析&quot;&gt;为什么需要JSON模板解析&lt;/h2&gt;

&lt;p&gt;Restful API的两个重要因素是输入和输出，一个好的API要求输入和输出都清晰可见。
输入包括用户提交的方式、参数等，都是可预期的。尽量不要采用数组接收。例如以下的例子，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$data = $_POST;
$User-&amp;gt;save($data);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的坏处一是无法过滤用户非法、多余的参数提交；二是参数不明，后续无法维护。&lt;/p&gt;

&lt;p&gt;输出则要求仅提供满足需要的最小的数据集。例如如下的例子，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$user = User::get(1);
echo $user-&amp;gt;toJson();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的坏处一是输出的内容不清晰，只有知道数据表的结构才能了解输出的内容；二是可能一不小心把用户表敏感字段（密码，手机号）输出，造成信息泄漏。&lt;/p&gt;

&lt;h2 id=&quot;jsonout库介绍&quot;&gt;JSONOut库介绍&lt;/h2&gt;

&lt;p&gt;解决输出的方法，是采用JSON模板解析的方法。例如用户表有id,name,pass,avatar,phone字段，其中只有name,avatar是需要输出的。那么模板可以这样定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;avatar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当输出用户数据时，仅保留name和avatar，其它字段自动过滤掉。&lt;/p&gt;

&lt;p&gt;优点是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输出结构一目了然&lt;/li&gt;
  &lt;li&gt;仅保留满足需要的最小的数据集&lt;/li&gt;
  &lt;li&gt;敏感字段自动过滤，减少信息泄露&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class JSONOut
{
	/**
	*按照JSON模板输出JSON数据
	*@param data 源数据
	*@param tplContent JSON模板内容
	*@param multi 是否为多条内容，默认单条
	*@return string
	*/
	public static function toJSON($data, $tplContent,$multi = false){
        if(empty($data)){
            return array();
        }
     
        $tplData = json_decode($tplContent,true);
        if(!$tplData){
            return false;
        }

        $array = array();
        if (!$multi) {
            // 一维数组
            $array = self::array_intersect_key_recursive($data,$tplData);
        } else {
            // 多维数组
            foreach($data as $key =&amp;gt; $value){
                $array[$key] = self::array_intersect_key_recursive($value,$tplData);
            }
        }

        return json_encode($array);
    }


    private static function array_intersect_key_recursive(array $array1, array $array2) {
        $array1 = array_intersect_key($array1, $array2);

        foreach ($array1 as $key =&amp;gt; &amp;amp;$value) {
            if (is_array($value) &amp;amp;&amp;amp; is_array($array2[$key])) {
                $value = $this-&amp;gt;array_intersect_key_recursive($value, $array2[$key]);
            }
        }
        return $array1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;测试代码&quot;&gt;测试代码&lt;/h2&gt;

&lt;p&gt;测试代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$tplContent = &amp;lt;&amp;lt;&amp;lt;EOT
{
  &quot;name&quot;: &quot;&quot;,
  &quot;avatar&quot;: &quot;&quot;
}
EOT;

//单条数据
$user  = array('id'=&amp;gt;1,'name' =&amp;gt; 'david','pass' =&amp;gt; '123456','phone'=&amp;gt;'13888888888','avatar' =&amp;gt; 'http://spetacular.github.io/images/favicon.ico');

echo JSONOut::toJSON($user,$tplContent,false);

echo &quot;\n&quot;;

//多条数据
$users  = [array('id'=&amp;gt;1,'name' =&amp;gt; 'david','pass' =&amp;gt; '123456','phone'=&amp;gt;'13888888888','avatar' =&amp;gt; 'http://spetacular.github.io/images/favicon.ico'),
array('id'=&amp;gt;2,'name' =&amp;gt; 'john','pass' =&amp;gt; '654321','phone'=&amp;gt;'13888888889','avatar' =&amp;gt; 'http://spetacular.github.io/images/favicon.png')];

echo JSONOut::toJSON($users,$tplContent,true);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试结果如下：&lt;/p&gt;

&lt;p&gt;单条数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;david&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;avatar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://spetacular.github.io/images/favicon.ico&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;多条数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
  {
    &quot;name&quot;: &quot;david&quot;,
    &quot;avatar&quot;: &quot;http://spetacular.github.io/images/favicon.ico&quot;
  },
  {
    &quot;name&quot;: &quot;john&quot;,
    &quot;avatar&quot;: &quot;http://spetacular.github.io/images/favicon.png&quot;
  }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##未来扩展
注意到JSON模板仅有key，没有value，未来可以在value上扩展，比如默认值，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;gender&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果数据里没有gender的数据，则默认为0；&lt;/p&gt;

&lt;p&gt;或者在value上加过滤函数，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;int&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;表示age要转化为整型数字。&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
